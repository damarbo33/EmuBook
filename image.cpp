// Class automatically generated by Dev-C++ New Class wizard
#include "image.h" // class's header file

// class constructor
TImagen::TImagen(SDL_Surface *screen) : TPantalla(screen)
{
	// insert your code here
    this->setFondo(clNegro);
    this->setColor(clBlanco);
    this->justificar = false;
    this->tamFuente = 10;
	bitmap = NULL;
	RAWbitmap = NULL;
	this->screen = screen;
	this->thumbVisible = false;
	top = 0;
	left = 0;
	autosize = true;
	zoomFactor = 0;
	rectPantalla = new SDL_Rect();
	rectPantalla->x=0;
	rectPantalla->y=0;
	rectPantalla->w=screen->w;
	rectPantalla->h=screen->h;
	moveIncFactor = 20;
	retrasoPresentacion = 2000;

    //Datos para el thumb de imagenes
    this->posicionImgThumb = 0;
    this->thumb_w = 150;
    this->thumb_h = 150;
    this->separacion = 1;

    //Creamos un array con los valores enteros de todos los colores
    SDL_Color *s_color = new SDL_Color();
    SDL_PixelFormat *fmt;
    fmt=screen->format;
    for (int i = 0;i<10;i++)
    {
        putColor(i,s_color);
        arrayColores[i] = SDL_MapRGB(fmt,s_color->r,s_color->g,s_color->b);
    }
	//objTraza->print("TImagen::TImagen() antes de cargar iconos");

//    this->cargarIconos();
    //objTraza->print("TImagen::TImagen() iconos cargados");
}

// class destructor
TImagen::~TImagen()
{
	objTraza->print("TImagen::~TImagen()");
	SDL_FreeSurface(bitmap);
	SDL_FreeSurface(RAWbitmap);


    objTraza->print("Borramos iconos");
	for (int i=0;i<arrayIcons.numIcons;i++)
	{
        SDL_FreeSurface(arrayIcons.Icon[i]);
	}
	objTraza->print("Fin");
}

bool TImagen::cargarIconos()
{
    arrayIcons.numIcons = 31;

    #ifdef GP2X
        arrayIcons.Icon[0] = IMG_Load("imgs/page_white_text.png");
        arrayIcons.Icon[1] = IMG_Load("imgs/folder.png");
        arrayIcons.Icon[2] = IMG_Load("imgs/page_white.png");
        arrayIcons.Icon[3] = IMG_Load("imgs/bullet_go.png");
        arrayIcons.Icon[4] = IMG_Load("imgs/door_out.png");
        arrayIcons.Icon[5] = IMG_Load("imgs/bullet_wrench.png");
        arrayIcons.Icon[6] = IMG_Load("imgs/clock.png");
        arrayIcons.Icon[7] = IMG_Load("imgs/page_find.png");
        arrayIcons.Icon[8] = IMG_Load("imgs/folder_explore.png");
        arrayIcons.Icon[9] = IMG_Load("imgs/magnifier.png");
        arrayIcons.Icon[10] = IMG_Load("imgs/chart_bar.png");
        arrayIcons.Icon[11] = IMG_Load("imgs/cross.png");
        arrayIcons.Icon[12] = IMG_Load("imgs/tick.png");
        arrayIcons.Icon[13] = IMG_Load("imgs/font.png");
        arrayIcons.Icon[14] = IMG_Load("imgs/font_add.png");
        arrayIcons.Icon[15] = IMG_Load("imgs/color_swatch.png");
        arrayIcons.Icon[16] = IMG_Load("imgs/text_align_justify.png");
        arrayIcons.Icon[17] = IMG_Load("imgs/layout_sidebar.png");
        arrayIcons.Icon[18] = IMG_Load("imgs/clock_delete.png");
        arrayIcons.Icon[19] = IMG_Load("imgs/book_go.png");
        arrayIcons.Icon[20] = IMG_Load("imgs/bullet_black.png");
        arrayIcons.Icon[21] = IMG_Load("imgs/page_white_gear.png");
        arrayIcons.Icon[22] = IMG_Load("imgs/page_white_compressed.png");
        arrayIcons.Icon[23] = IMG_Load("imgs/page_white_acrobat.png");
        arrayIcons.Icon[24] = IMG_Load("imgs/page_white_c.png");
        arrayIcons.Icon[25] = IMG_Load("imgs/page_white_h.png");
        arrayIcons.Icon[26] = IMG_Load("imgs/page_white_paint.png");
        arrayIcons.Icon[27] = IMG_Load("imgs/application_form_edit.png");
        arrayIcons.Icon[28] = IMG_Load("imgs/delete.png");
        arrayIcons.Icon[29] = IMG_Load("imgs/sound.png");
        arrayIcons.Icon[30] = IMG_Load("imgs/emoticon_waii.png");


    #else
        arrayIcons.Icon[0] = IMG_Load("imgs\\page_white_text.png");
        arrayIcons.Icon[1] = IMG_Load("imgs\\folder.png");
        arrayIcons.Icon[2] = IMG_Load("imgs\\page_white.png");
        arrayIcons.Icon[3] = IMG_Load("imgs\\bullet_go.png");
        arrayIcons.Icon[4] = IMG_Load("imgs\\door_out.png");
        arrayIcons.Icon[5] = IMG_Load("imgs\\bullet_wrench.png");
        arrayIcons.Icon[6] = IMG_Load("imgs\\clock.png");
        arrayIcons.Icon[7] = IMG_Load("imgs\\page_find.png");
        arrayIcons.Icon[8] = IMG_Load("imgs\\folder_explore.png");
        arrayIcons.Icon[9] = IMG_Load("imgs\\magnifier.png");
        arrayIcons.Icon[10] = IMG_Load("imgs\\chart_bar.png");
        arrayIcons.Icon[11] = IMG_Load("imgs\\cross.png");
        arrayIcons.Icon[12] = IMG_Load("imgs\\tick.png");
        arrayIcons.Icon[13] = IMG_Load("imgs\\font.png");
        arrayIcons.Icon[14] = IMG_Load("imgs\\font_add.png");
        arrayIcons.Icon[15] = IMG_Load("imgs\\color_swatch.png");
        arrayIcons.Icon[16] = IMG_Load("imgs\\text_align_justify.png");
        arrayIcons.Icon[17] = IMG_Load("imgs\\layout_sidebar.png");
        arrayIcons.Icon[18] = IMG_Load("imgs\\clock_delete.png");
        arrayIcons.Icon[19] = IMG_Load("imgs\\book_go.png");
        arrayIcons.Icon[20] = IMG_Load("imgs\\bullet_black.png");
        arrayIcons.Icon[21] = IMG_Load("imgs\\page_white_gear.png");
        arrayIcons.Icon[22] = IMG_Load("imgs\\page_white_compressed.png");
        arrayIcons.Icon[23] = IMG_Load("imgs\\page_white_acrobat.png");
        arrayIcons.Icon[24] = IMG_Load("imgs\\page_white_c.png");
        arrayIcons.Icon[25] = IMG_Load("imgs\\page_white_h.png");
        arrayIcons.Icon[26] = IMG_Load("imgs\\page_white_paint.png");
        arrayIcons.Icon[27] = IMG_Load("imgs\\application_form_edit.png");
        arrayIcons.Icon[28] = IMG_Load("imgs\\delete.png");
        arrayIcons.Icon[29] = IMG_Load("imgs\\sound.png");
        arrayIcons.Icon[30] = IMG_Load("imgs\\emoticon_waii.png");

    #endif

    return true;

}

void TImagen::pintarIcono(int numIcono,int x,int y)
{

    if (arrayIcons.Icon[numIcono] != NULL && numIcono < arrayIcons.numIcons)
    {
        //SDL_Surface *prueba = SDL_DisplayFormat(arrayIcons.Icon[0]);
        //SDL_Surface *prueba = SDL_ConvertSurface(arrayIcons.Icon[0], screen->format, SDL_SWSURFACE);
        //printf("prueba->w %d, prueba->h %d\n",prueba->w,prueba->h);
        SDL_Rect *rectIcono = new SDL_Rect();

        rectIcono->x=margenI + x - arrayIcons.Icon[numIcono]->w - 4;
        rectIcono->y=y;
        rectIcono->w=arrayIcons.Icon[numIcono]->w;
        rectIcono->h=arrayIcons.Icon[numIcono]->h;

        SDL_BlitSurface(arrayIcons.Icon[numIcono], NULL, screen, rectIcono);
        //SDL_FreeSurface(prueba);
    }

}


// Cargar la imagen
bool TImagen::LoadFromFile(char *file_name, bool actualizarPantalla)
{
    int inicio = SDL_GetTicks ();
    SDL_Surface *temp;
    bool salida = false;

    //traza *miTraza = new traza("/mnt/sd/salidota.txt");


    //printf("Antes de buscar la imagen\n");
    if (isImagen(file_name))
    {
        zoomFactor = 0;
        rectPantalla->x=0;
        rectPantalla->y=0;

        if (bitmap != NULL)
        {
            Clear();
//            drawText("Cargando la imagen. Espere un momento",0,0);
//            SDL_UpdateRect(screen, 0, 0, devolverTamanyoS("Cargando la imagen. Espere un momento"),tamFuente);
        }

        temp = IMG_Load(file_name);

        if (temp != NULL)
        {
           //bitmap = SDL_ConvertSurface(temp, screen->format, SDL_SWSURFACE);		// convert to hardware surface and copy to real surface
           SDL_FreeSurface(bitmap);
           SDL_FreeSurface(RAWbitmap);
           bitmap = SDL_DisplayFormat(temp);
           printf("SDL_DisplayFormat: %d\n",SDL_GetTicks ()- inicio);
           //Copiamos la imagen original sin hacer ningun cambio para procesos posteriores
           RAWbitmap = SDL_CreateRGBSurface(SDL_SWSURFACE, temp->w, temp->h, 16,0, 0, 0, 0);
           SDL_BlitSurface(bitmap, NULL,RAWbitmap , NULL);
           if (actualizarPantalla) drawSprite(bitmap, screen, 0, 0, temp->w, temp->h);
           printf("drawSprite: %d\n",SDL_GetTicks ()- inicio);
           salida = true;
        }
        else
        {
            Clear();
            drawText("Se ha producido algun error al cargar la imagen",0,0);
            printf("Se ha producido algun error al cargar la imagen\n");
        }

        int final = SDL_GetTicks ();
        SDL_FreeSurface(temp);
        printf("El tiempo al loadFromFile: %d\n",final-inicio);
    }
    else
    {
        Clear();
        drawText("El fichero no se reconoce como una imagen",0,0);
        printf("No es imagen\n");
    }

    if (!salida)
    {
        Clear();
        drawText("No se ha podido cargar la imagen",0,0);
        drawText(file_name,0,30);
    }

    //SDL_UpdateRect(screen, 0, 0, 0, 0);

    return salida;
}


//Aplicamos zoom dependiendo del parametro varSalto. Si varSalto -1 anumentamos la imagen
//si  varSalto 1 disminuimos la imagen
void TImagen::Zoom(int varSalto)
{
    float maxPercentZoom = 200; //Maximo zoom en porcentaje
    //Calculamos el factor de la imagen
    float var_relacion = relacion(RAWbitmap,screen->h,screen->w);
    float zoomAnterior = var_relacion + zoomFactor;
    this->zoomFactor += varSalto*0.4;
    float relacionZoom = var_relacion + zoomFactor;

    int percentZoom = (int)(100/relacionZoom);
    printf("el zoom es al %d\n",percentZoom);

    if (percentZoom > maxPercentZoom)
    {
        //Forzamos el zoom al máximo permitido
        relacionZoom = 100/maxPercentZoom;
        zoomFactor = zoomAnterior - var_relacion;
    }


    if (relacionZoom > var_relacion)
    {
        //No permitimos hacer la imagen más pequeña que la propia pantalla
        relacionZoom = var_relacion;
        zoomFactor = zoomAnterior - var_relacion;
    }


    ResizeSurface(relacionZoom, RAWbitmap);
    int centroX=(screen->w - (int)bitmap->w)/2;
    int centroY=(screen->h - (int)bitmap->h)/2;

    if (centroX < 0)
    {
        //Si hemos llegado al maximo no calculamos el nuevo punto de la pantalla al redimensionar
        if (relacionZoom == 100/maxPercentZoom)
            rectPantalla->x = rectPantalla->x;
        else
            rectPantalla->x = (int)(rectPantalla->x * zoomAnterior / relacionZoom + 0.1*screen->w/2*(-varSalto));

        if ( bitmap->w - rectPantalla->x < screen->w) rectPantalla->x = bitmap->w - screen->w;
    }
    else
    {
        rectPantalla->x = 0;
    }

    if (centroY < 0)
    {
          //Si hemos llegado al maximo no calculamos el nuevo punto de la pantalla al redimensionar
          if (relacionZoom == 100/maxPercentZoom)
            rectPantalla->y = rectPantalla->y;
          else
            rectPantalla->y = (int)(rectPantalla->y * zoomAnterior / relacionZoom + 0.1*screen->h/2*(-varSalto));

          if ( bitmap->h - rectPantalla->y < screen->h) rectPantalla->y = bitmap->h - screen->h;
    }
    else
    {
        rectPantalla->y = 0;
    }

    if (rectPantalla->x < 0) rectPantalla->x = 0;
    if (rectPantalla->y < 0) rectPantalla->y = 0;

    Refresh();
}


void TImagen::ZoomOriginal()
{
    SDL_FreeSurface(bitmap);
    bitmap = SDL_CreateRGBSurface(SDL_SWSURFACE, this->RAWbitmap->w, this->RAWbitmap->h, 16,0, 0, 0, 0);
    SDL_BlitSurface(RAWbitmap,NULL,bitmap,NULL);
    Refresh();
    zoomFactor =  1 - relacion(RAWbitmap,screen->h,screen->w);
}

//La parte superior izquierda de la pantalla es el punto 0,0
void TImagen::moverZoomPantallaX(int varSalto)
{
    varSalto *= moveIncFactor;
    if ((rectPantalla->x + varSalto >= 0) && (rectPantalla->x + screen->w + varSalto <= bitmap->w))
    {
        rectPantalla->x+=varSalto;
        Refresh();
    }
}

//La parte superior izquierda de la pantalla es el punto 0,0
void TImagen::moverZoomPantallaY(int varSalto)
{
    varSalto *= moveIncFactor;
    if ((rectPantalla->y + varSalto >= 0) && (rectPantalla->y + screen->h + varSalto <= bitmap->h) )
    {
        rectPantalla->y+=varSalto;
        Refresh();
    }
}

// Recargar la imagen almacenada en memoria ya redimensionada
void TImagen::Refresh(void)
{
    if (bitmap != NULL)
    {
         SDL_Rect *rectCentrado = new SDL_Rect();

         rectCentrado->x=(screen->w - (int)bitmap->w)/2;
         rectCentrado->y=(screen->h - (int)bitmap->h)/2;
         rectCentrado->w=screen->w;
         rectCentrado->h=screen->h;

         printf("Refrescamos en: %d,%d\n",screen->w,screen->h);

         //Si la imagen es mas grande que la pantalla pintamos a partir del punto de origen
         if (rectCentrado->x < 0)
         {
            rectCentrado->x = 0;
         }

         if (rectCentrado->y < 0)
         {
             rectCentrado->y = 0;
         }
         SDL_FillRect(screen,NULL,0x000000);
         SDL_BlitSurface(bitmap, rectPantalla,screen ,rectCentrado);
         SDL_UpdateRect(screen, 0, 0, 0, 0);
    }
}

//Volvemos a hacer el proceso de redimensionado y pintamos la imagen
void TImagen::RefreshAll(void)
{
    if (RAWbitmap != NULL)
    {
      zoomFactor = 0;
      SDL_FillRect(screen,NULL,0x000000);
      drawSprite(RAWbitmap, screen, 0, 0, RAWbitmap->w, RAWbitmap->h);
      rectPantalla->x=0;
      rectPantalla->y=0;
      rectPantalla->w=screen->w;
      rectPantalla->h=screen->h;
      SDL_UpdateRect(screen, 0, 0, 0, 0);
    }
}

//Redimensionamos una superficie al tamaño que queramos en base a la dimension
//relacion
void TImagen::ResizeSurface(float relacion, SDL_Surface *varBitmap)
{
    int inicio = SDL_GetTicks ();
    int width = varBitmap->w;
    int height = varBitmap->h;

    double newWidth =  varBitmap->w / relacion;
    double newHeight = varBitmap->h / relacion;

    //SDL_Surface *tempBitmap = SDL_CreateRGBSurface(SDL_SWSURFACE, (int)columnas, (int)filas, 16,0, 0, 0, 0);
    SDL_FreeSurface(bitmap);
    bitmap = SDL_CreateRGBSurface(SDL_SWSURFACE, (int)newWidth, (int)newHeight, 16,0, 0, 0, 0);

    printf("Vamos a convertir la superficie de: %d,%d a %d,%d\n",width,height,(int)newWidth,(int)newHeight);


    //Calculamos el array de los pixeles antes de hacerlo en el bucle for del putixel
    int arrayNewWidth[(int)newWidth];
    int arrayNewHeight[(int)newHeight];

    for (int tj=0;tj<newWidth-1;tj++)
    {
        arrayNewWidth[tj] = (int)(tj * relacion);
    }

    for (int ti=0;ti<newHeight-1;ti++)
    {
        arrayNewHeight[ti] = (int)(ti * relacion);
    }

//    int *pi=arrayNewHeight,*pj=arrayNewWidth;

    for (int i=0;i<newHeight-1;i++)
         for (int j=0;j<newWidth-1;j++)
             putpixel(bitmap, j, i,  getpixel(varBitmap,arrayNewWidth[j],arrayNewHeight[i]));

     printf("El tiempo al ResizeSurface: %d\n",SDL_GetTicks()-inicio);
}

// cambiar el tamanyo
void TImagen::Resize(float relacion)
{
     SDL_FillRect(screen,NULL,0x000000);
     //relacion = relacion - 0.5;
     int width=0, height=0;
     SDL_LockSurface(bitmap);
     width = RAWbitmap->w;
     height = RAWbitmap->h;
     double columnas =  RAWbitmap->w / relacion;
     double filas = RAWbitmap->h /relacion;

     if (columnas > screen->w) columnas = screen->w;
     if (filas > screen->h) filas = screen->h;

     //int *PosCenter = centrado(filas,columnas,screen->h, screen->w);
     int PosCenter[2];
     centrado(PosCenter,filas,columnas,screen->h, screen->w);

     top = PosCenter[0];
     left = PosCenter[1];

  //   int i=0,j=0;

     /* Lock the screen for direct access to the pixels */
    if ( SDL_MUSTLOCK(screen) ) {
        if ( SDL_LockSurface(screen) < 0 ) {
            fprintf(stderr, "Can't lock screen: %s\n", SDL_GetError());
            return;
        }
    }

    //Calculamos el array de los pixeles antes de hacerlo en el bucle for del putixel
    int arrayColumnas[(int)columnas];
    int arrayFilas[(int)filas];

    for (int tj=0;tj<columnas-1;tj++)
    {
        arrayColumnas[tj] = (int)(tj * relacion);
    }

    for (int ti=0;ti<filas-1;ti++)
    {
        arrayFilas[ti] = (int)(ti * relacion);
    }


//    int *pi=arrayFilas,*pj=arrayColumnas;

    for (int i=0;i<filas-1;i++)
         for (int j=0;j<columnas-1;j++)
             putpixel(screen, j+left, i+top,  getpixel(RAWbitmap,arrayColumnas[j],arrayFilas[i]));


     if ( SDL_MUSTLOCK(screen) ) {
        SDL_UnlockSurface(screen);
    }
     SDL_UnlockSurface(bitmap);
}


//Pintar cada Sprite
void TImagen::drawSprite(SDL_Surface* imageSurface, SDL_Surface* screenSurface, int srcX, int srcY, int width, int height)
{
//      int inicio = SDL_GetTicks ();

      float var_relacion = relacion(imageSurface,screen->h,screen->w);
      Resize(var_relacion);
//      int final = SDL_GetTicks ();
      //Asignamos la imagen redimensionada al bitmap para poder hacer un refresco con la imagen
      //ya redimensionada cuando sea necesario y no perder tiempo procesando
      SDL_FreeSurface(bitmap);
      bitmap = SDL_CreateRGBSurface(SDL_SWSURFACE, screen->w, screen->h, 16,0, 0, 0, 0);
      SDL_BlitSurface(screen, NULL, bitmap, NULL);
}

//Devuelve la relacion de una imagen para hacerla mas pequeña
float TImagen::relacion(SDL_Surface *visor, int alto, int ancho)
{
  float relacion=1;
  double altoFin=0;
  double anchoFin=0;

  if (autosize)
  {
   if (visor->w <= ancho && visor->h <= alto)
   {
      altoFin = visor->h;
      anchoFin  = visor->w;
   }
   else
   {
     if (visor->w > 0 && visor->h > 0)
     {
        relacion = visor->h / (float)visor->w;
        if (relacion > 1)
        {
                altoFin=alto;
                if (altoFin / (float)relacion < ancho)
                    anchoFin = floor(altoFin / relacion);
                else
                {
                    anchoFin = ancho;
                    altoFin = floor(anchoFin * relacion);
                }
        }
        else
        {
                anchoFin=ancho;
                if (anchoFin * (float)relacion < alto )
                {
                    altoFin = anchoFin * (float)relacion;
                }
                else
                {
                    altoFin = alto;
                    anchoFin = altoFin / (float)relacion;
                }
        }
     }
   }
  }
  else
  {
        altoFin=visor->h;
        anchoFin=visor->w;
  }
  if (altoFin!=0) relacion = (float)visor->h / altoFin;
  else relacion = 1;

  return relacion;
}

//Centra en la pantalla
void TImagen::centrado(int *posicion, double imAlto, double imAncho, int alto, int ancho)
{
   //int posicion [2] = {0,0};

   //top=(alto - (int)imAlto)/2;
   posicion[0]=(alto - (int)imAlto)/2;
   //left=(ancho - (int)imAncho)/2;
   posicion[1]=(ancho - (int)imAncho)/2;
   //return posicion;

}


/*
 * Return the pixel value at (x, y)
 * NOTE: The surface must be locked before calling this!
 */
Uint32  TImagen::getpixel(SDL_Surface *surface, int x, int y)
{
    int bpp = surface->format->BytesPerPixel;
    /* Here p is the address to the pixel we want to retrieve */
    Uint8 *p = (Uint8 *)surface->pixels + y * surface->pitch + x * bpp;

/*    switch(bpp) {
    case 1:
        return *p;

    case 2:
*/
        return *(Uint16 *)p;
/*
    case 3:
        if(SDL_BYTEORDER == SDL_BIG_ENDIAN)
            return p[0] << 16 | p[1] << 8 | p[2];
        else
            return p[0] | p[1] << 8 | p[2] << 16;

    case 4:

        return *(Uint32 *)p;

    default:
        return 0;
    }
*/
}
/*
 * Set the pixel at (x, y) to the given value
 * NOTE: The surface must be locked before calling this!
 */
void  TImagen::putpixel(SDL_Surface *surface, int x, int y, Uint32 pixel)
{
    int bpp = surface->format->BytesPerPixel;
    /* Here p is the address to the pixel we want to set */
    Uint8 *p = (Uint8 *)surface->pixels + y * surface->pitch + x * bpp;

/*    switch(bpp) {
    case 1:
         //printf("1");
        *p = pixel;
        break;

    case 2:
        //printf("2");
    */
        *(Uint16 *)p = pixel;
      /*  break;

    case 3:
         //printf("3");
        if(SDL_BYTEORDER == SDL_BIG_ENDIAN) {
            p[0] = (pixel >> 16) & 0xff;
            p[1] = (pixel >> 8) & 0xff;
            p[2] = pixel & 0xff;
        } else {
            p[0] = pixel & 0xff;
            p[1] = (pixel >> 8) & 0xff;
            p[2] = (pixel >> 16) & 0xff;
        }
        break;

    case 4:
         //printf("4");
        *(Uint32 *)p = pixel;
        break;
    }*/

}


/*
 * Return the pixel value at (x, y)
 * NOTE: The surface must be locked before calling this!
 */
Uint32 TImagen::getpixelbilinear(int x, int y)
{
    double fraction_x, fraction_y, one_minus_x, one_minus_y;
    Uint8 ceil_x, ceil_y, floor_x, floor_y;
    Uint32 c1, c2 ,c3 ,c4;
    Uint32 b1, b2;
    Uint8 red,green,blue;
    Uint8 c1r, c2r ,c3r ,c4r;
    Uint8 c1g, c2g ,c3g ,c4g;
    Uint8 c1b, c2b ,c3b ,c4b;


    floor_x = (int)x;
    floor_y = (int)y;
    ceil_x = floor_x + 1;
    if (ceil_x >= bitmap->w) ceil_x = floor_x;
    ceil_y = floor_y + 1;
    if (ceil_y >= bitmap->h) ceil_y = floor_y;
    fraction_x = x - floor_x;
    fraction_y = y - floor_y;
    one_minus_x = 1.0 - fraction_x;
    one_minus_y = 1.0 - fraction_y;

    c1 = getpixel(bitmap,floor_x, floor_y);
    c2 = getpixel(bitmap,ceil_x, floor_y);
    c3 = getpixel(bitmap,floor_x, ceil_y);
    c4 = getpixel(bitmap,ceil_x, ceil_y);

    SDL_GetRGB(c1,bitmap->format, &c1r,&c1g,&c1b);
    SDL_GetRGB(c2,bitmap->format, &c2r,&c2g,&c2b);
    SDL_GetRGB(c3,bitmap->format, &c3r,&c3g,&c3b);
    SDL_GetRGB(c4,bitmap->format, &c4r,&c4g,&c4b);

    b1 = (Uint8)(one_minus_x * c1r + fraction_x * c2r);
    b2 = (Uint8)(one_minus_x * c3r + fraction_x * c4r);

    red = (Uint8)(one_minus_y * (double)(b1) + fraction_y * (double)(b2));

    b1 = (Uint8)(one_minus_x * c1g + fraction_x * c2g);
    b2 = (Uint8)(one_minus_x * c3g + fraction_x * c4g);

    green = (Uint8)(one_minus_y * (double)(b1) + fraction_y * (double)(b2));

    b1 = (Uint8)(one_minus_x * c1b + fraction_x * c2b);
    b2 = (Uint8)(one_minus_x * c3b + fraction_x * c4b);

    blue = (Uint8)(one_minus_y * (double)(b1) + fraction_y * (double)(b2));

return (SDL_MapRGBA(bitmap->format,red,green,blue,255));

}

bool TImagen::isImagen(char *filename)
{

    //char extension[3] = {"  "};
    char extensiones [][4] = {"jpg","JPG","bmp","BMP","png","PNG","gif","GIF"};
    //char *extensiones [] = {"jpg","JPG","bmp","BMP","png"};
    //int pos_punto = -1;
    bool extension_encontrada = false;
    //Buscamos el punto de la extension del fichero
    if (filename != NULL)
    {
        int num_extensiones = sizeof(extensiones)/(4*sizeof(char));
        for (int k=0;k<num_extensiones-1;k++)
        {
            if (this->contiene(filename, extensiones[k]) >= 0)
            {
                extension_encontrada = true;
            }
        }
    }
    return extension_encontrada;
}

void TImagen::setRetrasoPresentacion(int var_dato)
{
    retrasoPresentacion = var_dato;
}

int TImagen::getRetrasoPresentacion()
{
    return retrasoPresentacion;
}


int TImagen::blur_slow_get_rgba(int sample_x, int sample_y, int radius)
{
    Uint32 count=0;
    Uint32 sum=0;

    //int inicio_i=sample_x-radius,fin_i=sample_x+radius;
    //int inicio_j=sample_y-radius,fin_j=sample_y+radius;

    int inicio_i=sample_x,fin_i=sample_x+radius;
    int inicio_j=sample_y,fin_j=sample_y+radius;

    if (inicio_i < 0) inicio_i=0;
    if (inicio_j < 0) inicio_j=0;
    if (fin_i > screen->w - 1) fin_i = screen->w - 1;
    if (fin_j > screen->h - 1) fin_j = screen->h - 1;

    Uint8 red=0,green=0,blue=0,alpha=0;
    Uint32 c1=0, c2=0 ,c3=0, c4=0;


    //Le ponemos i<= en lugar de i< y le quitamos el radius a inicio_i
    for (int i=inicio_i;i<=fin_i;i++)
    {
        for (int j=inicio_j;j<=fin_j;j++)
        {
            sum = getpixel(screen,i, j);
            SDL_GetRGBA(sum,screen->format, &red,&green,&blue,&alpha);
            c1+=red;
            c2+=green;
            c3+=blue;
            c4+=alpha;
            count++;
        }
    }

    if (count > 0)
    {
        red = c1/count;
        green = c2/count;
        blue = c3/count;
        alpha = c4/count;
        return (SDL_MapRGBA(screen->format,red,green,blue,alpha));
    }
    else
        return 0;
}


void TImagen::blur_image()
{
    SDL_Surface *blurScreen = SDL_CreateRGBSurface(SDL_SWSURFACE, screen->w, screen->h, 16,0, 0, 0, 0);
    for (int i=0;i<screen->w;i++)
    {
        for (int j=0;j<screen->h;j++)
        {
            putpixel(blurScreen,i, j,blur_slow_get_rgba(i,j,1));
        }
    }

    SDL_BlitSurface(blurScreen, NULL, screen, NULL);
    SDL_UpdateRect(screen, 0, 0, 0, 0);
    SDL_FreeSurface(blurScreen);
}


void TImagen::presentacion(TMenuData *var_menu)
{
    int max_campo = var_menu->menus[1].numCampos - 1;

     SDL_Event user_event_key;
     user_event_key.type=SDL_KEYUP;
     user_event_key.user.code=2;
     user_event_key.user.data1=NULL;
     user_event_key.user.data2=NULL;

     SDL_Event user_event_joy;
     user_event_key.type=SDL_JOYBUTTONUP;
     user_event_key.user.code=2;
     user_event_key.user.data1=NULL;
     user_event_key.user.data2=NULL;

    TTimer *reloj = new TTimer(retrasoPresentacion);
    SDL_Event evento;

    bool salir = false;

    for (int i=var_menu->posCampo;i<max_campo;i++)
    {
        if (isImagen(var_menu->menus[1].campo[i].nombre))
        if (this->LoadFromFile(var_menu->menus[1].campo[i].nombre,true))
        {
           SDL_UpdateRect(screen, 0, 0, 0, 0);
           var_menu->posCampo = i;
           reloj->eventTimer();
           if (SDL_PollEvent (&evento))
           {
               if ( (evento.type == SDL_KEYDOWN || evento.type == SDL_JOYBUTTONDOWN) )
                    salir = true;

               if ( evento.type == SDL_KEYDOWN ) SDL_PushEvent(&user_event_key);
               else if ( evento.type == SDL_JOYBUTTONDOWN ) SDL_PushEvent(&user_event_joy);
           }
           if (salir) return;
        }
    }
}


void TImagen::pintarTriangulo (int x, int y, int base, int altura, bool isUP, int r_color)
{
    //x e y son la cima del triangulo
    //      (x,y)
    //       /\    -
    //      /  \   |  altura
    //      ----   -
    //      base
    //      |--|

    // a^2 = b^2+c^2
    //
    // Parte derecha => Punto central Base = (x, y - altura)
    //                  vertice derecho = (x + base/2, y - altura)

//    int x_arriba=x - base/2;
    int x_der=x + base/2;
    int y_arriba=y;
    int y_debajo=y + altura;

    int numerador = (y_arriba - y_debajo);
    int denominador = (x - x_der);

    float pendiente = numerador/(float)denominador;

    //Funcion de la recta -> j = (y1-y2)/(x1-x2) * (i-x1) + y1
    int calc_j = 0;
    int baseNuevoPlano = y + altura;
    for (int j = y_arriba; j < y_debajo; j++)
    {
        for (int i = x; i < x_der; i++)
        {
            calc_j = (int)(pendiente * (i-x)) + y;

            if (j > calc_j)
            {
                if (!isUP)
                {
                    putpixel(screen,i,2*baseNuevoPlano - j - 2*altura,arrayColores[r_color]);
                    putpixel(screen,(2*x - i),2*baseNuevoPlano - j - 2*altura,arrayColores[r_color]);
                }
                else
                {
                    putpixel(screen,i,j,arrayColores[r_color]);
                    putpixel(screen,(2*x - i),j,arrayColores[r_color]);
                }

                /*lienzo->putpixel(screen,i,j,arrayColores[r_color]);
                lienzo->putpixel(screen,(2*x - i),j,arrayColores[r_color]);

                lienzo->putpixel(screen,i,2*baseNuevoPlano - j - 2*altura,arrayColores[r_color]);
                lienzo->putpixel(screen,(2*x - i),2*baseNuevoPlano - j - 2*altura,arrayColores[r_color]);
                */
            }
        }
    }
}




void TImagen::pintarCirculo (int x, int y, int r,int r_color)
{
    int centro_x=0;
    int centro_y=0;

    int x_izq=x - r;
    int x_der=x + r;
    int y_izq=y - r;
    int y_der=y + r;

    if (x_izq < 0) x_izq = 0;
    if (x_der > screen->w) x_der = screen->w - 1;
    if (y_izq < 0) y_izq = 0;
    if (y_der > screen->h) y_der = screen->h - 1;

    int raiz=0;
    int radio2 = r*r;

    int i=x_izq;
    int j=y_izq;


    while (i < x_der)
    {
        while (j < y_der)
        {
            centro_x = i - x;
            centro_y = j - y;
            //Funcion del circulo -> x^2 + y^2 = r^2
            raiz = centro_x*centro_x + centro_y*centro_y;
            //el -2 es un factor de corrección necesario para círculos pequeños, sino queda muy pixelado
            if (raiz < radio2-4)
            {
                putpixel(screen,i,j,arrayColores[r_color]);
            }
            j++;
        }
        i++;
        j=y_izq;
    }
}

void TImagen::pintarLinea (int x1, int y1, int x2, int y2 ,int r_color)
{
    int i = x1;
    int j = y1;

    int numerador = (y1-y2);
    int denominador = (x1-x2);
    float pendiente = 0;

    if (denominador != 0)
    {
        pendiente = numerador/(float)denominador;

        while (i <= x2 && i <= screen->w)
        {
            //Funcion de la recta -> j = (y1-y2)/(x1-x2) * (i-x1) + y1
            j = (int)(pendiente * (i-x1)) + y1;
            putpixel(screen,i,j,arrayColores[r_color]);
            i++;
        }
    }
    else
    {
        while (j <= y2 && j <= screen->h)
        {
            putpixel(screen,i,j,arrayColores[r_color]);
            j++;
        }
    }

}

void TImagen::thumbnail(TMenuData *var_menu)
{
    int max_campo = var_menu->menus[1].numCampos - 1;
    int screen_w = screen->w;
    int screen_h = screen->h;

    //Con este elemento comprobamos que estamos viendo el thumb de imagenes
    this->thumbVisible = true;

    SDL_Rect *rectCentrado = new SDL_Rect();

    rectCentrado->x=0;
    rectCentrado->y=0;
    rectCentrado->w=thumb_w;
    rectCentrado->h=thumb_h;

    float i_relacion = 0;

    int contador = var_menu->posCampo;

    Clear();
    SDL_UpdateRect(screen,0,0,0,0);

    int numFotoW = screen_w / (thumb_w+separacion);
    int numFotoH = screen_h / (thumb_h+separacion);


    int sobra_i = (screen_h - (numFotoH)*(thumb_h+separacion))/2;
    int sobra_j = (screen_w - (numFotoW)*(thumb_w+separacion))/2;

    int posCentrado[2];

    for (int i = 0;i < numFotoH && contador < max_campo; i++)
    {
        for (int j = 0;j < numFotoW && contador < max_campo; j++)
        {
            if (!isImagen(var_menu->menus[1].campo[contador].nombre))
            {
                while (!isImagen(var_menu->menus[1].campo[contador].nombre) && contador < max_campo)
                {
                    contador++;
                }
            }

            rectCentrado->x = sobra_j + j*thumb_w + j*separacion;
            rectCentrado->y = sobra_i + i*thumb_h + i*separacion;

            if (this->LoadFromFile(var_menu->menus[1].campo[contador].nombre,false))
            {
                 i_relacion = relacion(RAWbitmap,thumb_h,thumb_w);
                 ResizeSurface(i_relacion,RAWbitmap);
                 centrado(posCentrado,bitmap->h,bitmap->w,thumb_h,thumb_w);

                 rectCentrado->x += posCentrado[1];
                 rectCentrado->y += posCentrado[0];

                 SDL_BlitSurface(bitmap, NULL, screen , rectCentrado);
                 SDL_UpdateRect(screen,rectCentrado->x,rectCentrado->y,rectCentrado->w,rectCentrado->h);
                 printf("Pintamos :%s\n",var_menu->menus[1].campo[contador].nombre);

            }

            contador++;
        }
    }
}


void TImagen::fondoCirculos()
{
    pintarCirculo(80,120,160,clLila);
    pintarCirculo(240,120,160,clAzul);
    pintarCirculo(280,120,40,clLila);
}

void TImagen::thumbArriba()
{

}

void TImagen::thumbAbajo()
{
    int numFotoW = screen->w / (thumb_w+separacion);
    int numFotoH = screen->h / (thumb_h+separacion);

    int totalFotos = numFotoW*numFotoH;

    if (posicionImgThumb % numFotoW == 0 && posicionImgThumb > 0 && posicionImgThumb + numFotoW < totalFotos)
    {
       posicionImgThumb+=numFotoW;
    }

}

void TImagen::thumbIzquierda()
{
     if (posicionImgThumb > 0) posicionImgThumb--;
}

void TImagen::thumbDerecha()
{
    int numFotoW = screen->w / (thumb_w+separacion);
    int numFotoH = screen->h / (thumb_h+separacion);

    int totalFotos = numFotoW*numFotoH;

    if (posicionImgThumb + 1 < totalFotos)
    {
        posicionImgThumb++;
    }

    resaltarThumb(posicionImgThumb);
}

void TImagen::pintarTitulo(char *titulo)
{
    int posX;
    if (strcmp("",titulo) != 0 && titulo != NULL)
    {
        //int centroFuente = this->tamFuente+2;
//        objTraza->print("El titulo es",titulo);
        int centroFuente = 16+2;
        TTF_SizeText(font,titulo,&posX,NULL);
        int posTitulo = (screen->w - posX)/2;
        pintarCirculo(margenI + posTitulo, margenS + centroFuente/2 , centroFuente/2,clBlanco);
        pintarCirculo(margenI + posTitulo + posX, margenS + centroFuente/2 , centroFuente/2,clBlanco);
        SDL_Rect rectTitulo = { margenI + posTitulo,margenS+1, posX, centroFuente-1};
        //Pintamos el texto sobresaltado en color rojo Clblanco
        SDL_FillRect(screen, &rectTitulo, SDL_MapRGB(screen->format,255,255,255));
        this->setColor(clNegro);
//        objTraza->print("pintamos: ",titulo);
        drawText(titulo,posTitulo,margenS);
        this->setColor(clBlanco);
    }
}




void TImagen::resaltarThumb(int posicion)
{
     //SDL_UpdateRect(screen,0,0,0,0);
            /*
            Clear();
            char pos[30] = {"0"};
            itoa (posicion,pos,10);
            drawText(pos,0,0);
            SDL_UpdateRect(screen, 0, 0, devolverTamanyoS(pos),tamFuente+saltoLinea);
            */
    int numFotoW = screen->w / (thumb_w+separacion);
    int numFotoH = screen->h / (thumb_h+separacion);

    int sobra_i = (screen->h - (numFotoH)*(thumb_h+separacion))/2;
    int sobra_j = (screen->w - (numFotoW)*(thumb_w+separacion))/2;

    int posY = posicion / numFotoW;
    int posX = posicion % numFotoW;

    SDL_Rect *rectCentrado = new SDL_Rect();

    int posCentrado[2];
    centrado(posCentrado,bitmap->h,bitmap->w,thumb_h,thumb_w);

    rectCentrado->w=thumb_w;
    rectCentrado->h=thumb_h;
    rectCentrado->x = sobra_j + posX*thumb_w + posX*separacion + posCentrado[1];
    rectCentrado->y = sobra_i + posY*thumb_h + posY*separacion + posCentrado[0];

    SDL_Surface *tmpThumbImg = SDL_CreateRGBSurface(SDL_SWSURFACE, thumb_w, thumb_h, 16,0, 0, 0, 0);
    SDL_BlitSurface(screen, rectCentrado, tmpThumbImg , NULL);

    printf("posY %d,posX %d\n",posY,posX);

    rectCentrado->x -=  posCentrado[1];
    rectCentrado->y -= posCentrado[0];

    SDL_FillRect(screen,rectCentrado,0xFFFFFF);

    rectCentrado->x +=  posCentrado[1];
    rectCentrado->y += posCentrado[0];

    SDL_BlitSurface(tmpThumbImg, NULL,screen, rectCentrado);

    rectCentrado->x -=  posCentrado[1];
    rectCentrado->y -= posCentrado[0];

    SDL_UpdateRect(screen,rectCentrado->x,rectCentrado->y,rectCentrado->w,rectCentrado->h);

    SDL_FreeSurface(tmpThumbImg);
}
