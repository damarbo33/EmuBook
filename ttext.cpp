// Class automatically generated by Dev-C++ New Class wizard

#include "ttext.h" // class's header file

// class constructor
TText::TText(SDL_Surface *screen) : TPantalla(screen)
{
	objTraza->print("TText::TText()");
	fichero = new abrir_fichero();
    margenI = 3;
    margenD = 15;
    margenF = 13;
    margenS = 3;
    saltoLinea = 9;

	lineas.offset = NULL;
	ColorBookmark = SDL_MapRGB(screen->format,140,0,0);
	posLinea = 1;
	SetretrasoDesplazamientoPantalla(20);
	desplazamienoSuave = false;
	orientacion = 0;
	resetBookmarks();
	resetBusqueda();
    this->miImagen = new TImagen(screen);
    fichLang = new TConfig();
    if (fichLang->procesar_fichero("lang.ini"))
    {
       fichLang->obtenClaves();
    }
    objTraza->print("TText:: FIN Constructor TText()");
}

// class destructor
TText::~TText()
{
	delete fichero;
	delete fichLang;
	delete miImagen;
	free(lineas.offset);
}

/**
* txtBusqueda: Texto a buscar
* inicio: posicion de la primera letra en la que buscar
**/

int  TText::buscarTexto (char *txtBusqueda, int inicio, int sentido)
{

    char *texto = fichero->Gettexto();
    bool salir = false;
    int letras_encontradas = 0; //Contador de las letras encontradas
    int posicionEncontrada = -1; //Posicion encontrada dentro del libro
    int tam_libro = 0; //Tamano del fichero abierto
    int tamBusqueda = 0; //Tamano del texto a buscar

    if (texto != NULL && txtBusqueda != NULL)
    {
        tam_libro = strlen(texto);
        tamBusqueda = strlen(txtBusqueda);
        strcpy(this->palabraBuscar,txtBusqueda);

        if ( inicio < tam_libro)
        {
            if (sentido == 1)
            {
                for (int i=inicio;i < tam_libro && !salir;i++)
                {
                    //Comparamos incluso con mayusculas y minusculas +32
                    if ( texto[i] == txtBusqueda[letras_encontradas] ||
                        (int)texto[i] == (int)txtBusqueda[letras_encontradas] + 32 ||
                        (int)texto[i] + 32 == (int)txtBusqueda[letras_encontradas])
                    {
                        letras_encontradas++;
                    }
                    else
                    {
                        letras_encontradas = 0;
                    }

                    if (letras_encontradas == tamBusqueda)
                    {
                        salir = true;
                        posicionEncontrada = i - tamBusqueda + 1;
                    }
                }
            }
            else if (sentido == -1)
            {
                /**El sentido es hacia detrás**/
                letras_encontradas = tamBusqueda-1;

                for (unsigned int i=inicio;i > 0 && !salir;i--)
                {
                    //Comparamos incluso con mayusculas y minusculas +32
                    if ( texto[i] == txtBusqueda[letras_encontradas] ||
                        (int)texto[i] == (int)txtBusqueda[letras_encontradas] + 32 ||
                        (int)texto[i] + 32 == (int)txtBusqueda[letras_encontradas])
                    {
                        letras_encontradas--;
                        //printf("Encontrada la: %c\n",texto[i]);
                    }
                    else
                    {
                        letras_encontradas = tamBusqueda-1;
                    }

                    if (letras_encontradas < 0)
                    {
                        salir = true;
                        posicionEncontrada = i;
                    }
                }
            }

            posicionEncontrada+=1;
            //printf("posicionEncontrada %d\n",posicionEncontrada);
            this->ultimaPosicionBuscar = posicionEncontrada;

            if (posicionEncontrada >= 0)
            {
                //Hemos encontrado la posicion de la primera letra de la palabra buscada
                //Ahora buscamos la linea en la que está
                int filas = lineas.n_lineas;
                salir = false;
                int anterior = 0;
                int actual = 0;
                int lineaEncontrada = 0;

                for (int i=0; i < filas && !salir;i++)
                {
                    actual = this->lineas.offset[i];

                    if (posicionEncontrada >= anterior && posicionEncontrada <= actual)
                    {
                        lineaEncontrada = i;
                        //printf("La linea es la: %d\n",lineaEncontrada);
                        salir = true;
                        if (lineaEncontrada <= 0)
                        {
                            this->posLinea = 1;
                        }
                        else
                        {
                            this->posLinea = lineaEncontrada;
                        }
                        /**TODO**/
                        //Podríamos resaltar el texto encontrado
                        this->setForzarTextoRemarcar(this->palabraBuscar);
                        this->pintarPagina(true);
                    }
                    else
                    {
                        anterior = actual;
                    }
                }
            }

        }
    }

    //printf("TText::buscarTexto: FIN\n");
    return posicionEncontrada;
}


void TText::buscarSiguiente()
{
    if (ultimaPosicionBuscar != -1 && palabraBuscar != NULL)
    {
        this->buscarTexto(palabraBuscar,ultimaPosicionBuscar + strlen(palabraBuscar),1);
    }
}

void TText::buscarAnterior()
{
    if (ultimaPosicionBuscar != -1 && palabraBuscar != NULL)
    {
        this->buscarTexto(palabraBuscar,ultimaPosicionBuscar,-1);
    }
}

void TText::resetBookmarks()
{
  memset(arrayBookmarks.booklist,-1,sizeof(arrayBookmarks.booklist)/sizeof(int));
  arrayBookmarks.pos_bookmarks = 0;
  arrayBookmarks.prev_bookmarks = 0;
  arrayBookmarks.n_bookmarks = 0;
}

void TText::resetBusqueda()
{
  ultimaPosicionBuscar = -1;
  memset(palabraBuscar,' ',sizeof(palabraBuscar)/sizeof(char));
}


void TText::buscar_paginas(void)
{
  this->reset_linea();
  Clear();
  bool tempJustificar = justificar;
  justificar = false;
  this->resetBusqueda();
  this->resetBookmarks();
  int anchoLinea = 0;
  unsigned char leido[2] = {' ','\0'};
  unsigned long int posString = 0;
  char *texto = fichero->Gettexto();
  unsigned int tam = strlen(texto);
  bool tieneEspacio=true;
  bool retorno = false;
  unsigned long posEspacio = 0;

  objTraza->print("buscar_paginas: Antes de liberar");
  if (lineas.offset != NULL)
     free(lineas.offset);
  objTraza->print("buscar_paginas: Despues de liberar");

  unsigned int posDato = 0;
  printf("fuente clase: %d",tamFuente);

  objTraza->print("buscar_paginas: Fuente clase",tamFuente);
  //int tamFuente = this->tamFuente;

  int tamLetra = 0;
  //this->crearArrayTamanyos(this->font,tamFuente);

    lineas.offset = (int *)malloc(sizeof(int));
    lineas.offset[0]=0;
    posDato++;

    objTraza->print("buscar_paginas: memoria creada");
    //maxWidth

    bool tienePalabra = false;
    int inicioPalabra = 0;
    int tempPosString = 0;

     while(posString <= tam)
     {
            leido[0] = texto[posString];
            tamLetra = devolverTamanyo(leido[0]);


            if (texto[posString]==' ')
            {
               posEspacio=posString + 1;   //+1 para eliminar el espacio del principio de linea
               tieneEspacio = true;
            }

            if (anchoLinea + 2*tamLetra > this->maxWidth || posString == tam || esRetorno(leido[0]))
            {
                anchoLinea = 0;
                if (!esRetorno(leido[0]) && tieneEspacio && posString != tam)
                {
                    posString = posEspacio;
                }

                lineas.offset = (int *)realloc(lineas.offset,(posDato+1)*sizeof(int));
                lineas.offset[posDato]=posString;
                posDato++;
                posString++;
                tieneEspacio = false;
                msg_processing(posString, tam);
            }
            else
            {
                anchoLinea += tamLetra;
            }

            posString++;
     }
     lineas.n_lineas = posDato - 1;
     //printf("Tiempo empleado:%d\n",SDL_GetTicks()-now);

    if (tam > 0)
    {
        msg_processing(posString, tam);
    }
    objTraza->print("buscar_paginas: Fin del mensaje de procesando");
    justificar = tempJustificar;
    objTraza->print("buscar_paginas: Justificado");
    //taxonomia();
}


// No description

/*
void TText::buscar_paginas(void)
{
  this->reset_linea();
  Clear();
  bool tempJustificar = justificar;
  justificar = false;
  this->resetBusqueda();
  this->resetBookmarks();
  int anchoLinea = 0;
  unsigned char leido[2] = {' ','\0'};
  unsigned long int posString = 0;
  char *texto = fichero->Gettexto();
  unsigned int tam = strlen(texto);
  bool tieneEspacio=true;
  bool retorno = false;
  unsigned long posEspacio = 0;
  if (lineas.offset != NULL)
     free(lineas.offset);

  unsigned int posDato = 0;
  printf("fuente clase: %d",tamFuente);

  //int tamFuente = this->tamFuente;

  int tamLetra = 0;
  //this->crearArrayTamanyos(this->font,tamFuente);

    lineas.offset = (int *)malloc(sizeof(int));
    lineas.offset[0]=0;
    posDato++;

    //maxWidth

    bool tienePalabra = false;
    int inicioPalabra = 0;

     while(posString <= tam)
     {
            leido[0] = texto[posString];
            tamLetra = devolverTamanyo(leido[0]);
            //printf("Leemos: %s,%d,%d\n",leido,posString,tam);

            retorno = esRetorno(leido[0]);

            if (retorno)
            {
                 posString++;
                 //retorno = false;
            }

            if ((texto[posString] != ' ') && !retorno)
            {
                if (!tienePalabra) inicioPalabra = posString;
                tienePalabra = true;
            }
            else
            {
                //No estamos escribiendo palabras con lo que podemos cortar para la siguiente linea si se requiere
                tienePalabra = false;
                //Si la palabra era un retorno, No quiero que aparezca en el texto
            }


            if (anchoLinea >= this->maxWidth || posString == tam || retorno)
            {
                //printf("Cortamos por lugar con palabra\n");
                if (tienePalabra && posString < tam) posString = inicioPalabra - 1;
                lineas.offset = (int *)realloc(lineas.offset,(posDato+1)*sizeof(int));
                lineas.offset[posDato]=posString;
                posDato++;
                anchoLinea = 0;
                msg_processing(posString, tam);
                tienePalabra = false;
            }
            else
            {
                anchoLinea += tamLetra;
            }
            posString++;
            //if (retorno) posString++;
     }

     lineas.n_lineas = posDato - 1;
     //printf("Tiempo empleado:%d\n",SDL_GetTicks()-now);

    if (tam > 0)
    {
        msg_processing(posString, tam);
    }

    justificar = tempJustificar;
    //taxonomia();
}
*/



void TText::repaginarFavoritos (float relacion)
{
    int repaginado = 0;
    for (int i = 0; i< arrayBookmarks.n_bookmarks;i++)
    {
        repaginado = (int)ceil(arrayBookmarks.booklist[i]*relacion);
        if (repaginado < 1) repaginado = 1;
        arrayBookmarks.booklist[i] = repaginado;
    }
}

int TText::posicionLinea (int pos_linea)
{
    int lineas_pantalla = this->maxHeight / (tamFuente + saltoLinea);
    float h_libre = (this->maxHeight - (lineas_pantalla * (tamFuente + saltoLinea)))/(float)2 ;
    int num_lineas = 0;

    if (lineas.n_lineas <= lineas_pantalla)
    {
         num_lineas = this->posLinea + lineas.n_lineas -1;
    }
    else
    {
         num_lineas = this->posLinea + lineas_pantalla -1;
    }

    if (num_lineas > lineas.n_lineas)
    {
       num_lineas = lineas.n_lineas;
    }

    float incremento = 0;

    if (lineas_pantalla != 0)
    {
        incremento = h_libre / (float)(lineas_pantalla) * 2;
    }

    float contador_incremento = pos_linea*incremento;

    //int posicionY = (int)contador_incremento + (pos_linea)*(tamFuente + saltoLinea) + margenI;
    int posicionY = (int)contador_incremento + (pos_linea)*(tamFuente + saltoLinea) + margenS;
    //int posicionY = (pos_linea)*(tamFuente + saltoLinea);

    return posicionY;

}

void TText::setDesplazamientoSuave(bool valor)
{
    desplazamienoSuave = valor;
}

void TText::pintarBarraVertical()
{
    if (lineas.n_lineas > 0 && this->getBarra())
    {
        int lineas_pantalla = this->maxHeight / (tamFuente + saltoLinea);
        float percent = (this->posLinea - 1)/(float)lineas.n_lineas*100;
        int scrollbarTop = (int)(percent * screen->h / 100);
        int scrollbarWidth = 1;
        int scrollbarHeight = 10;

        //Hacemos la altura de la barra proporcional al numero de lineas del libro
        float percentScrollbarHeight = lineas_pantalla/(float)lineas.n_lineas;
        int tempScrollbarHeight = (int)(screen->h * percentScrollbarHeight);
        if (tempScrollbarHeight > scrollbarHeight)
        {
            scrollbarHeight = tempScrollbarHeight;
        }

        //Reseteamos el fondo en el que pintamos la barra
        //SDL_Rect scroolbarRectFondo = { screen->w - scrollbarWidth - 1, 0, scrollbarWidth, screen->h};
        //SDL_FillRect(screen, &scroolbarRectFondo, arrayColores[clGris]);
        //Pintamos la barra de progreso
        SDL_Rect scroolbarRect = { screen->w - scrollbarWidth - 1, scrollbarTop, scrollbarWidth, scrollbarHeight};
        SDL_FillRect(screen, &scroolbarRect, arrayColores[clRojo]);
    }
}

// A partir de la línea actual pinta el resto de la página.
void TText::pintarPagina(bool borraPantalla)
{
    char *texto = fichero->Gettexto();
    int cont_linea = 0; //Contador de las lineas que vamos pintando solo en pantalla
    int lineas_pantalla = this->maxHeight / (tamFuente + saltoLinea);
    float h_libre = (this->maxHeight - (lineas_pantalla * (tamFuente + saltoLinea)))/(float)2 ;
    char *linea_pintar;
    int num_lineas = 0;

    //20081025
     int altoLinea = posicionLinea(1)-posicionLinea(0); /*Indica el alto que tiene una linea de pantalla*/
    //20081025

    if (lineas.n_lineas <= lineas_pantalla)
    {
         num_lineas = this->posLinea + lineas.n_lineas -1;
    }
    else
    {
         num_lineas = this->posLinea + lineas_pantalla -1;
    }

    if (num_lineas > lineas.n_lineas)
    {
       num_lineas = lineas.n_lineas;
    }

    //Si borra pantalla es false no podemos borrar la pantalla para pintar la linea de los favoritos
    if (borraPantalla) this->Clear();


    float incremento = 0;

    if (lineas_pantalla != 0)
    {
        incremento = h_libre / (float)(lineas_pantalla) * 2;
    }

    float contador_incremento = 0;
    bool finalPunto = false;
    bool antesJustificar = false;

    pintarBarraVertical();

    totalPalabrasPantalla = 0;

    if (this->posLinea > 0)
    {
        for (int i=this->posLinea; i <= num_lineas; i++)
        {
            linea_pintar = new char[this->lineas.offset[i] - this->lineas.offset[i-1] +1];
            memset(linea_pintar,'\0',this->lineas.offset[i] - this->lineas.offset[i-1] +1);
            strncpy(linea_pintar,&texto[this->lineas.offset[i-1]],this->lineas.offset[i] - this->lineas.offset[i-1]);
            antesJustificar = this->justificar;
            //printf("linea: %s\n",linea_pintar);
            //Para no justificar la linea si el final es un punto y aparte o dos puntos
            if (linea_pintar[strlen(linea_pintar)-1]=='.' || linea_pintar[strlen(linea_pintar)-1]==':')
            {
               this->justificar=false;
               finalPunto = true;
            }
    //        else
    //            this->justificar=true;
            eliminar_retornos(linea_pintar);
            //printf("ret: %s\n",linea_pintar);
            charTab(linea_pintar);
            //printf("tabs: %s\n",linea_pintar);
            sustituirCarateres(linea_pintar);
            //printf("sus: %s\n",linea_pintar);

            //desde aqui se pintan los bookmarks
            for (int contBookmark = 0; contBookmark < arrayBookmarks.n_bookmarks; contBookmark++)
            {
                if (arrayBookmarks.booklist[contBookmark] == i)
                {
                    SDL_Rect pantalla = { 0,posicionLinea(cont_linea)+2,screen->w, altoLinea-4};
                    SDL_FillRect(screen, &pantalla, ColorBookmark);
                }
            }

            //printf("pintamos: %s\n",linea_pintar);
			if (strcmp(linea_pintar,"")!=0 && strcmp(linea_pintar," ")!=0)
			{
				this->drawText(linea_pintar,0,posicionLinea(cont_linea));
			}
            //pintarLinea(0,posicionLinea(cont_linea),screen->w,posicionLinea(cont_linea), clRojo);

            if (antesJustificar && finalPunto)
                this->justificar=true;

            delete [] linea_pintar;
            contador_incremento += incremento;
            cont_linea++;
        }
    }



    //pintarLinea(0,posicionLinea(lineas_pantalla-1),screen->w,posicionLinea(lineas_pantalla-1), clVerde);
/*
    //La primera parte de la superficie doble será lo que ya habia por pantalla
    SDL_Surface* screenInicio = SDL_CreateRGBSurface(SDL_SWSURFACE, screen->w, screen->h*2, 16,0, 0, 0, 0);

    SDL_Rect pantallaOrigen = { 0,screen->h - altoLinea,screen->w, altoLinea-1};
    SDL_Rect pantallaDestino = { 0,screen->h, screen->w, altoLinea-1};

    //SDL_BlitSurface(screen, NULL, screenInicio, NULL);
    SDL_BlitSurface(screen, &pantallaOrigen, screenInicio, &pantallaDestino);



    SDL_Rect desplazaPantalla = { 0,0, screen->w, screen->h};
    //SDL_BlitSurface(screenInicio, &desplazaPantalla, screen, NULL);
    //SDL_BlitSurface(screenInicio, NULL, screen, NULL);
    //SDL_UpdateRect(screen, 0, 0, 0, 0);

    if (desplazamienoSuave)
    {
        printf("Antes de pintar el desplaza");

        for (int i = 0; i< altoLinea;i++)
        {
            desplazaPantalla.y = i;

            SDL_BlitSurface(screenInicio, &desplazaPantalla, screen, NULL);
            SDL_UpdateRect(screen, 0, 0, 0, 0);
            printf("Pintamos %d\n",i);
        }
    }

    SDL_FreeSurface(screenInicio);
*/
}









void TText::sustituirCarateres(char *dato)
{
    Uint8 tam = strlen(dato);
    unsigned char leido = ' ';
    //int i=0;
    //printf("Sustituir: %s\n",dato);
    for(int i=0;i<tam;i++)
    {
          leido = dato[i];
          //printf("%d %c\n",(int)leido,leido);
          if ((int)leido == 150 || (int)leido == 151)
              dato[i]='-';
          else if (dato[i]=='\224' || (int)leido == 147)
              dato[i]='"';
          else if (dato[i]=='\222')
               dato[i]='\'';
    }

}
/*
bool TText::esRetorno(char dato)
{
     char carControl[] = "\r\n";
     Uint8 tam = strlen(carControl);
     bool salir = false;
     Uint8 pos = 0;

     while (!salir && pos < tam)
     {
         if (dato == carControl[pos])
         {
             salir = true;
         }
         pos++;
     }

     return salir;
}
*/

// No description
void TText::eliminar_retornos(char *dato)
{
	Uint8 tam = strlen(dato);
    //int retornosEliminados = 0;
    unsigned char leido = ' ';

    //printf("eliminar_retornos: tam: %d: s: %s\n",tam,dato);
	for (int i=0;i<tam;i++)
	{
	    leido = dato[i];
	    //printf("ret: %d %c\n",(int)leido,leido);
        if (esRetorno(dato[i]))
        {
            dato[i]=' ';
//            retornosEliminados++;
        }
    }
/*
    for (int i=retornosEliminados;i<tam;i++)
	{
        dato[i-retornosEliminados]=dato[i];
    }

    for (int i=tam-1;i >= tam - retornosEliminados;i--)
	{
        dato[i]=' ';
    }
*/
    //printf("antes de trim: %s\n",dato);
    stringTrim(dato);
    //printf("despues de trim: %s\n",dato);
}

void TText::siguiente_linea()
{
     int lineas_pantalla = this->maxHeight / (tamFuente + saltoLinea);

     if (this->lineas.n_lineas - this->posLinea >= lineas_pantalla)
     {
         posLinea++;
         orientacion = 1;
     }
     else
     {
//        printf("LlEgamos al final\n");
        orientacion = 0;
     }
}


void TText::anterior_linea()
{
     if (posLinea > 1)
     {
        posLinea--;
        orientacion = -1;
     }
     else
     {
        orientacion = 0;
     }
}

// No description
void TText::siguiente_pagina()
{

    int lineas_pantalla = this->maxHeight / (tamFuente + saltoLinea);

    if (this->lineas.n_lineas - this->posLinea >= lineas_pantalla)
    {
        posLinea += lineas_pantalla;
        orientacion = 2;

        if (posLinea > this->lineas.n_lineas - lineas_pantalla)
        {
            posLinea = this->lineas.n_lineas - lineas_pantalla + 1;
        }
    }
    else
    {
        orientacion = 0;
    }

}

// No description
void TText::anterior_pagina()
{
	int lineas_pantalla = this->maxHeight / (tamFuente + saltoLinea);


	if (this->posLinea > this->posLinea - lineas_pantalla && (this->posLinea - lineas_pantalla) > 0)
	{
        posLinea -= lineas_pantalla;
        orientacion = -2;
	}
    else
        posLinea = 1;
}



void TText::reset_linea()
{
     posLinea = 1;
}

void TText::pintarTodo()
{
    Clear();
    SDL_UpdateRect(screen, 0, 0, 0, 0);
//    printf("num_lineas= %d\n",lineas.n_lineas);
    for (int i=1;i < lineas.n_lineas; i++)
    {
                  siguiente_linea();
                  //printf("%d\n",i);
                  pintarPagina(true);
                  SDL_UpdateRect(screen, 0, 0, 0, 0);
    }
    this->drawText("FIN",0,0);
    SDL_UpdateRect(screen, 0, 0, 0, 0);
}

void TText::setOrientacion(int temp_orientacion)
{
    this->orientacion = temp_orientacion;
}

void TText::desplazarPantalla()
{
    //int lineas_pantalla = maxHeight / (this->tamFuente + this->saltoLinea);
    int altoLinea = this->posicionLinea(1) - this->posicionLinea(0); //Indica el alto que tiene una linea de pantalla
    int lineas_pantalla = maxHeight / altoLinea;

    int inicioLinea = this->margenS;
//    int k = 0; //Contador de los pixeles verticales que vamos recorriendo 0:screen->h
    int altoCopiar = this->maxHeight;
    SDL_Event evento;
    int lineaInicial = this->posLinea; //Indica la linea desde la que hemos empezado a avanzar página

     SDL_Event user_event_key;
     user_event_key.type=SDL_KEYUP;
     user_event_key.user.code=2;
     user_event_key.user.data1=NULL;
     user_event_key.user.data2=NULL;

     SDL_Event user_event_joy;
     user_event_key.type=SDL_JOYBUTTONUP;
     user_event_key.user.code=2;
     user_event_key.user.data1=NULL;
     user_event_key.user.data2=NULL;


    //Resulta que en posicionLinea(0) tengo el alto de separacion con la primera linea
    //SDL_Surface* screenInicio = SDL_CreateRGBSurface(SDL_SWSURFACE, this->maxWidth, this->maxHeight + altoLinea, 16,0, 0, 0, 0);
    SDL_Surface* screenInicio = SDL_CreateRGBSurface(SDL_SWSURFACE, this->maxWidth, this->maxHeight+altoCopiar, 16,0, 0, 0, 0);
    SDL_Rect pantallaScreen = { this->margenI,this->margenS,this->maxWidth, this->maxHeight};

    //La primera parte de la superficie doble será lo que ya habia por pantalla
    SDL_BlitSurface(screen, &pantallaScreen, screenInicio, NULL);

    this->siguiente_pagina();
    this->pintarPagina(true);
    //this->setDesplazamientoSuave(false);

    this->posLinea = lineaInicial;

    //Definimos pantallaOrigen como la posicion de la ultima linea que se ha pintado por la pantalla
    //SDL_Rect pantallaOrigen = { this->margenI,this->posicionLinea(lineas_pantalla) - altoLinea + 2 ,this->maxWidth, altoLinea-2};
    SDL_Rect pantallaOrigen = { this->margenI,inicioLinea + 2 ,this->maxWidth, altoCopiar-2};
    //Definimos pantallaDestino como la posicion en la que pintamos esta linea en nuestra supoerficie screenInicio
    SDL_Rect pantallaDestino = { 0,this->maxHeight, this->maxWidth, altoCopiar};
    //añadimos a scrrenInicio la ultima linea pintada en la pantalla
    SDL_BlitSurface(screen, &pantallaOrigen, screenInicio, &pantallaDestino);
    //Definimos el rectangulo que iremos moviendo para pintar por la pantalla
    SDL_Rect desplazaPantalla = { 0,0, this->maxWidth , this->maxHeight};
    //Ahora en screenInicio tenemos toda la informacion necesaria. Podemos desplazar por la pantalla

    SDL_Rect TopesPantalla = { this->margenI,this->margenS, this->maxWidth, this->maxHeight};

    bool salir = false;

    if (this->posLinea + lineas_pantalla > this->lineas.n_lineas+1)
    {
       salir=true;
       return;
    }

    for (int i = 0; i <= this->maxHeight  && !salir;i++)
    {
        if ((i) % altoLinea == 0 && i != 0)
        {
            this->posLinea++;
        }

        desplazaPantalla.y = i;
        SDL_BlitSurface(screenInicio, &desplazaPantalla, screen, &TopesPantalla);
        pintarBarraVertical();
        SDL_UpdateRect(screen, 0, 0, 0, 0);
        SDL_Delay(retrasoDesplazamientoPantalla);

        if (this->posLinea + lineas_pantalla > this->lineas.n_lineas+1)
        {
            salir=true;
        }

        if (SDL_PollEvent (&evento))
        {
             if ( (evento.type == SDL_KEYDOWN || evento.type == SDL_JOYBUTTONDOWN) )
             {
                if  (evento.jbutton.button == GP2X_BUTTON_VOLUP || evento.key.keysym.sym == 'w' )
                {
                    retrasoDesplazamientoPantalla+=20;
                }
                else if (evento.jbutton.button == GP2X_BUTTON_VOLDOWN || evento.key.keysym.sym == 'e')
                {
                    if (retrasoDesplazamientoPantalla > 0)
                    retrasoDesplazamientoPantalla-=20;
                }
                else
                {
                    salir=true;
                }
                if ( evento.type == SDL_KEYDOWN ) SDL_PushEvent(&user_event_key);
                else if ( evento.type == SDL_JOYBUTTONDOWN ) SDL_PushEvent(&user_event_joy);
             }
        }
    }

    //SDL_BlitSurface(screenInicio, &desplazaPantalla, screen, NULL);
    //SDL_UpdateRect(screen, 0, 0, 0, 0);
    //SDL_UpdateRect(screen, 0, 0, 0, 0);
    SDL_FreeSurface(screenInicio);


    if (!salir) desplazarPantalla();
    else
    {
        pintarPagina(true);
        SDL_UpdateRect(screen,0,0,screen->w,screen->h);
    }

}

/*
void TText::desplazarPantalla()
{
     int lineas_pantalla = this->maxHeight / (tamFuente + saltoLinea);
     //int inicio = SDL_GetTicks ();
     int k = 0; //Contador de los pixeles verticales que vamos recorriendo 0:screen->h

     bool salir=false; //Indica si debemos salir del bucle principal de este metodo
     SDL_Rect scrollPantalla = { 0, screen->h, screen->w, screen->h };
     int altoLinea = posicionLinea(1)-posicionLinea(0); //Indica el alto que tiene una linea de pantalla
     int lineaInicial = this->posLinea; //Indica la linea desde la que hemos empezado a avanzar página
     int inicioLineasPintar = 0;
     int inicioScroll = 0;
     SDL_Event evento;

         //if ((k) % altoLinea == 0 && this->posLinea + lineas_pantalla >= this->lineas.n_lineas)
         if (this->posLinea + lineas_pantalla >= this->lineas.n_lineas+1)
         {
            salir=true;
            return;
         }



     SDL_Surface* screen2x = SDL_CreateRGBSurface(SDL_SWSURFACE, screen->w, screen->h*2, 16,0, 0, 0, 0);
     //La primera parte de la superficie doble será lo que ya habia por pantalla
     SDL_BlitSurface(screen, NULL, screen2x, NULL);

     siguiente_pagina();
     pintarPagina(true);

     this->posLinea = lineaInicial-1;
     //this->posLinea = lineaInicial;

     inicioLineasPintar = this->lineas.n_lineas-lineaInicial-lineas_pantalla+1;
     if (inicioLineasPintar < lineas_pantalla)
     {
        inicioScroll = screen->h-inicioLineasPintar*altoLinea;
     }

     SDL_Rect pantallaCortada = { 0, inicioScroll, screen->w, screen->h };

     SDL_Rect pantalla2x = { 0, screen->h, screen->w, 2*screen->h };
     //SDL_BlitSurface(screen, NULL, screen2x, &pantalla2x);
     SDL_BlitSurface(screen, &pantallaCortada, screen2x, &pantalla2x);

     SDL_Event user_event_key;
     user_event_key.type=SDL_KEYUP;
     user_event_key.user.code=2;
     user_event_key.user.data1=NULL;
     user_event_key.user.data2=NULL;

     SDL_Event user_event_joy;
     user_event_key.type=SDL_JOYBUTTONUP;
     user_event_key.user.code=2;
     user_event_key.user.data1=NULL;
     user_event_key.user.data2=NULL;


     //SDL_FreeSurface(screen);
     //screen = SDL_SetVideoMode (320, 240, 16, SDL_HWSURFACE|SDL_DOUBLEBUF|SDL_ANYFORMAT);

     while (!salir && k < screen->h)
     {
         if ((k) % altoLinea == 0)
         {
            this->posLinea++;
         }

         scrollPantalla.y = k;

         SDL_BlitSurface(screen2x, &scrollPantalla, screen, NULL);
         pintarBarraVertical();

         //SDL_Flip(screen);
         SDL_UpdateRect(screen,0,0,screen->w,screen->h);
         //inicio = SDL_GetTicks();
         k++;

         SDL_Delay(retrasoDesplazamientoPantalla);

         if (k >= screen->h)
         {
                lineaInicial = this->posLinea;

                inicioLineasPintar = this->lineas.n_lineas-lineaInicial-lineas_pantalla+1;
                if (inicioLineasPintar < lineas_pantalla)
                {
                 inicioScroll = screen->h-inicioLineasPintar*altoLinea;
                 pantallaCortada.y = inicioScroll;
                }
                else
                {
                    inicioScroll = 0;
                    pantallaCortada.y = inicioScroll;
                }
                 //Copiamos la ultima imagen que habia en pantalla al inicio del array de doble pantalla
                 SDL_BlitSurface(screen, NULL, screen2x, NULL);
                 siguiente_pagina();
                 pintarPagina(true);

                 //Ahora pintamos la siguiente imagen.
                 SDL_BlitSurface(screen, NULL, screen2x, &pantalla2x);
                 SDL_BlitSurface(screen, &pantallaCortada, screen2x, &pantalla2x);
                 k=0;
                 this->posLinea = lineaInicial-1;
         }

//         printf("Estamos en %d, de %d\n",this->posLinea + lineas_pantalla,this->lineas.n_lineas+1);
         //if ((k) % altoLinea == 0 && this->posLinea + lineas_pantalla >= this->lineas.n_lineas)
         if (this->posLinea + lineas_pantalla >= this->lineas.n_lineas+1)
         {
            salir=true;
         }


         if (SDL_PollEvent (&evento))
         {
             if ( (evento.type == SDL_KEYDOWN || evento.type == SDL_JOYBUTTONDOWN) )
             {
                if  (evento.jbutton.button == GP2X_BUTTON_VOLUP || evento.key.keysym.sym == 'w' )
                {
                    retrasoDesplazamientoPantalla+=10;
                }
                else if (evento.jbutton.button == GP2X_BUTTON_VOLDOWN || evento.key.keysym.sym == 'e')
                {
                    if (retrasoDesplazamientoPantalla > 0)
                    retrasoDesplazamientoPantalla-=10;
                }
                else
                {
                    salir=true;
                }
                if ( evento.type == SDL_KEYDOWN ) SDL_PushEvent(&user_event_key);
                else if ( evento.type == SDL_JOYBUTTONDOWN ) SDL_PushEvent(&user_event_joy);
             }
         }
     }



     //SDL_FreeSurface(screen);
     //screen = SDL_SetVideoMode (320, 240, 16, SDL_SWSURFACE|SDL_ANYFORMAT);
     pintarPagina(true);
     //SDL_BlitSurface(screen2x, &scrollPantalla, screen, NULL);
     SDL_UpdateRect(screen,0,0,screen->w,screen->h);
     SDL_FreeSurface(screen2x);
}
*/

void TText::AsignarBookmarks(char * listaBookmarks)
{
    char *p;

    if (listaBookmarks != NULL)
    {
        p = strtok(listaBookmarks, ",");
        do
        {
            if (p != NULL)
            {
                if (atoi(p) > 0)
                {
                    this->addBookmarks(&this->arrayBookmarks,atoi(p));
                }
            }
        }
        while ((p = strtok(NULL, ","))!=NULL);
    }
}

/**
* Metodo que va remarcando las palabras en la pantalla para indicar cual es la palabra
* seleccionada para buscar su definicion en el diccionario
*/
bool TText::definiciones()
{
    objTraza->print("TText::definiciones");
    bool salir = false;
    bool pulsaReturn = false;
    this->setPosMarcaPalabra(0);

    SDL_Event user_event_key;
    user_event_key.type=SDL_KEYUP;
    user_event_key.user.code=2;
    user_event_key.user.data1=NULL;
    user_event_key.user.data2=NULL;

    SDL_Event user_event_joy;
    user_event_joy.type=SDL_JOYBUTTONUP;
    user_event_joy.user.code=2;
    user_event_joy.user.data1=NULL;
    user_event_joy.user.data2=NULL;

    objTraza->print("TText::definiciones","Reiniciamos la palabra remarcada");
    setPosMarcaPalabra(getPosMarcaPalabra()+1);
    this->marcarPalabra();
    objTraza->print("TText::definiciones","Inicio bucle");

    while (!salir)
    {
        /* Check for events */
        SDL_Event event;

        while (SDL_WaitEvent(&event) && !salir)
        {
             switch (event.type)
             {
                case SDL_KEYDOWN:
                case SDL_JOYBUTTONDOWN:

                    if (event.key.keysym.sym == 'd' || event.jbutton.button == GP2X_BUTTON_SELECT)
                    {
                        objTraza->print("TText::definiciones","Volvemos al texto o al menu");
                        stopPosMarcaPalabra();
                        int tempPos = this->posLinea;
                        this->pintarPagina(true);
                        this->posLinea = tempPos;
                        salir = true;
                        SDL_UpdateRect(screen, 0, 0, 0, 0);
                        clearPalabraRemarcada();
                        objTraza->print("TText::definiciones","Fin if evento d");
                    }
                    if ( (event.key.keysym.sym == SDLK_DOWN || event.jbutton.button == GP2X_BUTTON_DOWN))
                    {
                        setPosMarcaPalabra(getPosMarcaPalabra()+1);
                        this->marcarPalabra();
                    }
                    else
                    if ( (event.key.keysym.sym == SDLK_UP || event.jbutton.button == GP2X_BUTTON_UP))
                    {
                        setPosMarcaPalabra(getPosMarcaPalabra()-1);
                        this->marcarPalabra();
                    }
                    else
                    if (event.key.keysym.sym == SDLK_RETURN || event.jbutton.button == GP2X_BUTTON_B)
                    {
                        printf("Vamos a buscar: %s\n",getPalabraRemarcada());
                        salir = true;
                        stopPosMarcaPalabra();
                    }

                    break;

                default: break;
             }//switch (event.type)
        }//while (SDL_PollEvent

            if ( event.type == SDL_KEYDOWN || event.type == SDL_KEYUP)
            {
                SDL_PushEvent(&user_event_key);
            }
            else if ( event.type == SDL_JOYBUTTONDOWN || event.type == SDL_JOYBUTTONUP)
            {
                SDL_PushEvent(&user_event_joy);
            }
    }//while (!salir)
    return pulsaReturn;
}

bool TText::favoritos ()
{

    bool salir = false;
    bool pulsaReturn = false;
    bool favoritoEncontrado = false;
    int lineaFavorito = 0;
    int lineas_pantalla = this->maxHeight / (tamFuente + saltoLinea);
    int posicionMarcada = 0;

    SDL_Event user_event_key;
    user_event_key.type=SDL_KEYUP;
//    user_event_key.type=SDL_KEYEVENT;
    user_event_key.user.code=2;
    user_event_key.user.data1=NULL;
    user_event_key.user.data2=NULL;

    SDL_Event user_event_joy;
    user_event_joy.type=SDL_JOYBUTTONUP;
    //user_event_key.type=SDL_JOYEVENTMASK;
    user_event_joy.user.code=2;
    user_event_joy.user.data1=NULL;
    user_event_joy.user.data2=NULL;

    //printf("Entramos en los favoritos\n");

    this->favoritosPantalla(lineaFavorito);

    while (!salir)
    {
        /* Check for events */
        SDL_Event event;

        while (SDL_WaitEvent(&event) && !salir)
        {

             switch (event.type)
             {
                case SDL_KEYDOWN:
                case SDL_JOYBUTTONDOWN:

                    favoritoEncontrado = false;
                    if (event.key.keysym.sym == 'f' || event.key.keysym.sym == SDLK_ESCAPE || event.jbutton.button == GP2X_BUTTON_A)
                    {
                        int tempPos = this->posLinea;
                        this->pintarPagina(true);
                        this->posLinea = tempPos;
                        salir = true;
                        SDL_UpdateRect(screen, 0, 0, 0, 0);
                    }
                    /*if (event.key.keysym.sym == SDLK_RETURN || event.jbutton.button == GP2X_BUTTON_START)
                    {
                        salir = true;
                        pulsaReturn = true;
                    }
                    else*/
                    if ( (event.key.keysym.sym == SDLK_DOWN || event.jbutton.button == GP2X_BUTTON_DOWN) && lineaFavorito < lineas_pantalla-1)
                    {
                        lineaFavorito++;
                        this->favoritosPantalla(lineaFavorito);
                    }
                    else
                    if ( (event.key.keysym.sym == SDLK_UP || event.jbutton.button == GP2X_BUTTON_UP) && lineaFavorito > 0)
                    {
                        lineaFavorito--;
                        this->favoritosPantalla(lineaFavorito);
                    }
                    else
                    if (event.key.keysym.sym == SDLK_RIGHT || event.jbutton.button == GP2X_BUTTON_R)
                    {
                        //printf("Pulsamos la s: %d\n",arrayBookmarks.booklist[arrayBookmarks.pos_bookmarks]);

                        if (arrayBookmarks.pos_bookmarks < arrayBookmarks.n_bookmarks-1)
                        {
                            arrayBookmarks.pos_bookmarks++;
                        }

                        if (arrayBookmarks.booklist[arrayBookmarks.pos_bookmarks] != -1)
                        {
                            //printf("Entramos a movernos por el array: %d\n",arrayBookmarks.booklist[arrayBookmarks.pos_bookmarks] );

                            this->posLinea = arrayBookmarks.booklist[arrayBookmarks.pos_bookmarks];
                            //this->favoritosPantalla(lineaFavorito);
                            this->pintarPagina(true);
                            SDL_UpdateRect(screen, 0, 0, 0, 0);
                        }

                    }
                    else
                    if (event.key.keysym.sym == SDLK_LEFT || event.jbutton.button == GP2X_BUTTON_L)
                    {
                            if (arrayBookmarks.pos_bookmarks > 0)
                            {
                                arrayBookmarks.pos_bookmarks--;
                            }

                            if (arrayBookmarks.booklist[arrayBookmarks.pos_bookmarks] != -1)
                            {
                                this->posLinea = arrayBookmarks.booklist[arrayBookmarks.pos_bookmarks];
                                this->pintarPagina(true);
                                SDL_UpdateRect(screen, 0, 0, 0, 0);
                            }
                    }
                    else
                    if (event.key.keysym.sym == SDLK_RETURN || event.jbutton.button == GP2X_BUTTON_B)
                    {
                        posicionMarcada = this->posLinea + lineaFavorito;
                        //printf("estamos en: %d, lineaFavorito es: %d\n",posicionMarcada,lineaFavorito );

                        for (int contBookmark = 0; contBookmark < arrayBookmarks.n_bookmarks; contBookmark++)
                        {
                            if (arrayBookmarks.booklist[contBookmark] == posicionMarcada)
                            {
                                //Eliminamos el bookmark y reordenamos el array
                                borrarBookmarks(&arrayBookmarks, contBookmark);
                                favoritoEncontrado = true;
                            }
                        }

                        if (favoritoEncontrado == false && posicionMarcada > 0)
                        {
                              addBookmarks(&arrayBookmarks, posicionMarcada);
                        }

                        this->favoritosPantalla(lineaFavorito);
                    }

                    break;

                default: break;
             }//switch (event.type)
        }//while (SDL_PollEvent
    //SDL_PeepEvents(&event,10,SDL_GETEVENT,SDL_KEYEVENTMASK);
            if ( event.type == SDL_KEYDOWN || event.type == SDL_KEYUP)
            {
                SDL_PushEvent(&user_event_key);
            }
            else if ( event.type == SDL_JOYBUTTONDOWN || event.type == SDL_JOYBUTTONUP)
            {
                SDL_PushEvent(&user_event_joy);
            }
    }//while (!salir)

    //printf("Hemos salido\n");
    return pulsaReturn;


}

void TText::borrarBookmarks (t_bookmarks *structBookmark, int inicioOrdenacion)
{
/*
    for (int contBookmark = 0; contBookmark < 10; contBookmark++)
    {
        printf("bookmark: %d\n",arrayBookmarks.booklist[contBookmark]);
    }
*/

    //En primer lugar eliminamos el bookmark
    for (int contBookmark = inicioOrdenacion; contBookmark < structBookmark->n_bookmarks; contBookmark++)
    {
            if (contBookmark ==  structBookmark->n_bookmarks-1)
            {
                arrayBookmarks.booklist[contBookmark] = -1;
            }
            else
            {
                arrayBookmarks.booklist[contBookmark] = arrayBookmarks.booklist[contBookmark+1];
            }
    }

    if (structBookmark->n_bookmarks > 0) structBookmark->n_bookmarks--;

/*    for (int contBookmark = 0; contBookmark < 10; contBookmark++)
    {
        printf("bookmarkEnd: %d\n",arrayBookmarks.booklist[contBookmark]);
    }
*/
}

void TText::addBookmarks (t_bookmarks *structBookmark, int posBookmark)
{
    int anterior=0;
    int posterior=0;
    bool salir = false;

//    printf("Anadimos el: %d\n",posBookmark);

    if (arrayBookmarks.n_bookmarks < (int)(sizeof(structBookmark->booklist)/sizeof(int)) )
    {
        for (int contBookmark = 0; contBookmark < structBookmark->n_bookmarks && !salir; contBookmark++)
        {
            posterior = structBookmark->booklist[contBookmark];

            if (posBookmark < posterior && posBookmark > anterior)
            {
                //Hemos encontrado la posicion en la que anadir el bookmark
                for (int contArray = structBookmark->n_bookmarks; contArray > contBookmark; contArray--)
                {
                    if (contArray >= 1) arrayBookmarks.booklist[contArray] = arrayBookmarks.booklist[contArray-1];
                }
                 arrayBookmarks.booklist[contBookmark] = posBookmark;
                 structBookmark->n_bookmarks++;
                 salir = true;
            }
            else
            {
                anterior = posterior;
            }
        }

        //Si no hemos encontrado el lugar en el que insertarlo es porque va al final del array
        if (salir == false)
        {
            arrayBookmarks.booklist[structBookmark->n_bookmarks] = posBookmark;
            structBookmark->n_bookmarks++;
        }
    }
}

void TText::favoritosPantalla(int lineaFavorito)
{
    Clear();
//    SDL_Rect scrollPantalla = { 0, screen->h, screen->w, screen->h };
    int altoLinea = posicionLinea(1)-posicionLinea(0); /*Indica el alto que tiene una linea de pantalla*/
    int lineaInicial = this->posLinea; /*Indica la linea desde la que hemos empezado a avanzar página*/

    SDL_Rect pantalla = { 0,posicionLinea(lineaFavorito),screen->w, altoLinea};
    SDL_FillRect(screen, &pantalla, SDL_MapRGB(screen->format,140,140,0));

    this->pintarPagina(false);
    this->posLinea = lineaInicial;

    SDL_UpdateRect(screen, 0, 0, 0, 0);
}

void TText::marcarPalabra()
{
    objTraza->print("TText::marcarPalabra()");

    Clear();
    int lineaInicial = this->posLinea; /*Indica la linea desde la que hemos empezado a avanzar página*/
    objTraza->print("this->posLinea, antes de pintar",this->posLinea);
    this->pintarPagina(false);
    objTraza->print("this->posLinea, despues de pintar",this->posLinea);
    this->posLinea = lineaInicial;
    SDL_UpdateRect(screen, 0, 0, 0, 0);
    objTraza->print("TText::marcarPalabra()","Fin");
}


void TText::msg_info(char *str_msg)
{
  bool TempJustificar = justificar;
  int sizeMsg = devolverTamanyoS(str_msg);
  int pos_v = (screen->h - (2*tamFuente+saltoLinea))/2;
  Clear();
  if (justificar) justificar = false;
  drawText(str_msg,(screen->w - sizeMsg)/2,pos_v);
  SDL_UpdateRect(screen, 0, 0, 0, 0);
  justificar = TempJustificar;
}



void TText::msg_processing(unsigned long int posString, unsigned int tam)
{

    bool TempJustificar = justificar;
   //if ((posString % 500 == 0 || posString >= tam-1 ) && tam > 0)
   if ((posString % 500 == 0 || posString >= tam-1 ) && tam > 0)
   {
        char *msg=fichLang->getClave("mProcess");
        int sizeMsg = devolverTamanyoS(msg);
        int sizePercent = devolverTamanyoS("100%");
        int pos_v = (screen->h - (2*tamFuente+saltoLinea))/2;
        justificar = false;
        //const int radio = 10;
        const int radio = tamFuente/2;
        const int posX = 40;
        int ancho = screen->w - 2*posX -radio;
        const int posY = pos_v + tamFuente + saltoLinea + radio;
        char datosProgreso[30];
        SDL_Rect rectTitulo = { posX + radio/2-1,posY - radio+1, ancho, radio*2-1};
        int numColor = getFontColor();

      SDL_FillRect(screen, NULL, arrayColores[6]);
      this->miImagen->fondoCirculos();

      this->miImagen->pintarCirculo(posX, posY , radio,clBlanco);
      this->miImagen->pintarCirculo(posX + ancho, posY , radio,clBlanco);
      SDL_FillRect(screen, &rectTitulo, arrayColores[clBlanco]);

      ancho = ancho * (posString/(float)tam);

      this->miImagen->pintarCirculo(posX, posY , radio-1,clAzul);
      this->miImagen->pintarCirculo(posX + ancho, posY , radio-1,clAzul);

      SDL_Rect rectTitulo2 = { posX + radio/2-1,posY - radio+1+1, ancho, (radio-1)*2-1};
      SDL_FillRect(screen, &rectTitulo2, arrayColores[clAzul]);


      this->setColor(clBlanco);

      drawText(msg,(screen->w - sizeMsg)/2,pos_v);

      if (posString > tam/2)
        this->setColor(clBlanco);
      else
        this->setColor(clNegro);

      sprintf(datosProgreso,"%2.0f",posString/(float)tam*100);
      strcat(datosProgreso,"%");
      drawText(datosProgreso,(screen->w - sizePercent)/2,pos_v + tamFuente + saltoLinea);

      SDL_UpdateRect(screen, 0, 0, 0, 0);
      this->setColor(numColor);
   }

   justificar = TempJustificar;
}

// returns the value of retrasoDesplazamientoPantalla
unsigned int TText::GetretrasoDesplazamientoPantalla()
{
	return retrasoDesplazamientoPantalla;
}


// sets the value of retrasoDesplazamientoPantalla
void TText::SetretrasoDesplazamientoPantalla(int x)
{
	retrasoDesplazamientoPantalla = x;
}
