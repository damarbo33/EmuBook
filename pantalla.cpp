// Class automatically generated by Dev-C++ New Class wizard

#include "pantalla.h" // class's header file


// class constructor
TPantalla::TPantalla(SDL_Surface *screen)
{
    printf("Iniciamos pantalla\n");
    textoForzadoRemarcar = NULL;
    objTraza = new traza();
    fontNumColor = 6;

    objTraza->print("TPantalla::TPantalla INICIO");

    rutaSeleccion = new char[MAXPATH];
    getDirActual(rutaSeleccion);
    font = NULL;
    margenI = 3;
    margenD = 5;
    margenF = 3;
    margenS = 3;

    tamFuente = 16;
    //saltoLinea = tamFuente/5;
    saltoLinea = 3;
    spacTabs = 5;
    this->LoadFont(tamFuente);
    this->screen=screen;

    this->crearArrayTamanyos(this->font,tamFuente);
    fontColor = new SDL_Color();
    bkgColor = new SDL_Color();
    this->setFondo(clBlanco);
    this->setColor(clNegro);
    cursorX=0;
    cursorY=0;
    justificar = true;
    maxWidth = screen->w-margenI-margenD;
    maxHeight = screen->h-margenF-margenS;
    //Creamos un array con los valores enteros de todos los colores
    SDL_Color *s_color = new SDL_Color();
    SDL_PixelFormat *fmt;
    fmt=screen->format;
    for (int i = 0;i<10;i++)
    {
        putColor(i,s_color);
        arrayColores[i] = SDL_MapRGB(fmt,s_color->r,s_color->g,s_color->b);
    }

    objTraza->print("TPantalla::TPantalla Fin");
    posMarcaPalabra = -1;
    totalPalabrasPantalla = 0;
    //strcpy(palabraRemarcada,NULL);
}


int TPantalla::getPosMarcaPalabra()
{
    return posMarcaPalabra;
}


void TPantalla::setPosMarcaPalabra(int pos)
{
    if (pos >= 0 && pos <= totalPalabrasPantalla)
    {
        posMarcaPalabra = pos;
    }
}

void TPantalla::stopPosMarcaPalabra()
{
    posMarcaPalabra = -1;
}

// class destructor
TPantalla::~TPantalla()
{

    delete fontColor;
    delete bkgColor;

}


// Borra el contenido de la pantalla
void TPantalla::Clear(void)
{
    SDL_Rect pantalla = { 0,0,screen->w, screen->h};
    SDL_FillRect(screen, &pantalla, SDL_MapRGB(screen->format,bkgColor->r,bkgColor->g,bkgColor->b));
}


void TPantalla::drawText(char* datos, int x, int y)
{
    //y += margenS;
    //printf("texto: %s\n",datos);
    SDL_Color textColor = { fontColor->r,fontColor->g,fontColor->b };
    SDL_Rect textLocation = { margenI + x, y, 0, 0 };
    //int posX=0,posY=0;
    int posX=0;
    //objTraza->print("drawText: datos: ",datos);
    int len = strlen(datos);

    char *p;
    int sumWord = 0;
    int numWord = 0;

    char *datos_temp = new char[strlen(datos)+1];
    char *datos_temp1 = new char [strlen(datos)+1];

    for (int i=0;i<len;i++)
    {
        datos_temp[i] = datos[i];
        datos_temp1[i] = datos[i];
    }

    datos_temp[strlen(datos)] = '\0';
    datos_temp1[strlen(datos)] = '\0';

    if (justificar)
    {
        p = strtok(datos_temp1, " ");
        //if (p != NULL) TTF_SizeText(font,p,&posX,&posY);
        if (p != NULL) posX=devolverTamanyoS(p);
        sumWord=posX;
        numWord = 1;
/*
        if (p == NULL)  totalPalabrasPantalla=0;
        else if (strcmp(" ",p) == 0) totalPalabrasPantalla=0;
        else totalPalabrasPantalla=1;
*/
        while ((p = strtok(NULL, " "))!=NULL)
        {
            charTab(p);
            posX=devolverTamanyoS(p);
            sumWord+=posX;
            numWord++;
        }

        //printf("Total %d palabras %s\n",totalPalabrasPantalla, datos_temp);

        float espacio = 0;

        if (numWord != 1)
        {
            espacio = (screen->w - sumWord - margenI - margenD)/(float)(numWord-1);
            //printf("El espacio es: %d\n",espacio);
        }
        else
        {
            //printf("Una palabra: %s\n",datos);
            if (datos != NULL)
            if (strcmp(datos,"")!=0 && strcmp(datos," ")!=0)
            {
                objTraza->print("TPantalla::drawText Hay una palabra que remarcar");
                totalPalabrasPantalla++;
                remarcarPalabra(x + margenI, y, posX,datos);
                objTraza->print("TPantalla::drawText FIN Hay una palabra que remarcar");
            }
            SDL_Surface* textSurface1 = TTF_RenderText_Blended(font,datos, textColor);
            SDL_BlitSurface(textSurface1, NULL, screen, &textLocation);
            SDL_FreeSurface(textSurface1);
        }

        sumWord = 1;
        numWord = 1;
        if (espacio > 0)
        {
            //if (espacio < screen->w/(int)6)
            if (espacio < tamFuente*2)
            {
                //Escribimos con justificado
                drawLinea(datos_temp,x,y,espacio,numWord);
            }
            else
            {
                //Escribimos sin justificado
                drawLinea(datos_temp,x,y,0,1);
            }
        }
        else
        {
            //Aunque no tenemos espacio pintamos igalmente
            drawLinea(datos_temp,x,y,0,1);
        }
    }
    else
    {
        //Escribimos sin justificado
        drawLinea(datos_temp,x,y,0,1);
    }
    delete(datos_temp);
    delete(datos_temp1);
}

void TPantalla::drawLinea (char *datos_temp, int x, int y, float espacio,int numWord)
{
    SDL_Color textColor = { fontColor->r,fontColor->g,fontColor->b };
    char *p;
    int sumWord = 1;

    int posX=0;
    //printf("Pintamos %s\n",datos_temp);

    p = strtok(datos_temp, " ");
    if (p != NULL)  posX=devolverTamanyoS(p);

    totalPalabrasPantalla++;
    if (p != NULL)
    {
        SDL_Surface* textSurface2 = TTF_RenderText_Blended(font,p, textColor);
        //SDL_Surface* textSurface2 = TTF_RenderText_Solid(font,p, textColor);
        SDL_Rect textLocation = { x + margenI, y, 0, 0 };
        objTraza->print("TPantalla::drawLinea Antes de remarcar");
        remarcarPalabra(x + margenI, y, posX,p);
        SDL_BlitSurface(textSurface2, NULL, screen, &textLocation);
        SDL_FreeSurface(textSurface2);
        sumWord = posX;
    }

    while ((p = strtok(NULL, " "))!=NULL)
    {
        totalPalabrasPantalla++;
        charTab(p);
        SDL_Surface* textSurface3 = TTF_RenderText_Blended(font, p, textColor);
        //SDL_Surface* textSurface3 = TTF_RenderText_Solid(font, p, textColor);
        if (espacio == 0) sumWord += devolverTamanyoS(" ");
        SDL_Rect textLocation2 = { (Uint16)floor(sumWord + numWord*espacio + margenI + x), y, 0, 0 };
        if (p != NULL)  posX=devolverTamanyoS(p);
        objTraza->print("TPantalla::drawLinea Antes de remarcar en el while");
        remarcarPalabra((Uint16)floor(sumWord + numWord*espacio + margenI + x), y,posX,p);
        objTraza->print("TPantalla::drawLinea Antes del blit");
        SDL_BlitSurface(textSurface3, NULL, screen, &textLocation2);
        objTraza->print("Liberamos surface");
        if (textSurface3 == NULL) objTraza->print("Surface es null");
        SDL_FreeSurface(textSurface3);
        numWord++;
        sumWord += posX;
        objTraza->print("Fin paso bucle");
    }
    objTraza->print("TPantalla::drawLinea Pantalla dibujada");
}

void TPantalla::remarcarPalabra(int x, int y, int ancho, char *s_palabraRemarcada)
{
        objTraza->print("TPantalla::remarcarPalabra()");
        if (totalPalabrasPantalla == posMarcaPalabra && posMarcaPalabra >= 0 || (textoForzadoRemarcar != NULL && contiene(s_palabraRemarcada,textoForzadoRemarcar) >= 0))
        {
            objTraza->print("TPantalla::Es posible remarcar",s_palabraRemarcada);
            SDL_Rect pantalla = { x, y, ancho+1, tamFuente+saltoLinea};
            setPalabraRemarcada(s_palabraRemarcada);
            //Pintamos el texto sobresaltado en color rojo ClRojo
            SDL_FillRect(screen, &pantalla, SDL_MapRGB(screen->format,255,0,0));
        }
        objTraza->print("TPantalla::Fin remarcar");
}

void TPantalla::setPalabraRemarcada(char * s_temp)
{

    if (s_temp != NULL)
    {
        clearPalabraRemarcada();
        //palabraRemarcada = new char(strlen(s_temp)+1);
        strcpy(palabraRemarcada,s_temp);
    }
}

void TPantalla::clearPalabraRemarcada()
{
    //delete palabraRemarcada;
    strcpy(palabraRemarcada,"");
    //strcpy(palabraRemarcada,NULL);
}


char * TPantalla::getPalabraRemarcada()
{
    return palabraRemarcada;
}


bool TPantalla::LoadFont(int size)
{
    objTraza->print("TPantalla::LoadFont");
    DIR *dir;
    struct dirent *ent;
    int contador = 0;

    char fich_fuente[MAXPATH];
    objTraza->print("Antes de copiar1");
    strcpy(fich_fuente,this->rutaSeleccion);

    objTraza->print("Antes de copiar2");
    char directorio[MAXPATH];
    strcpy(directorio,this->rutaSeleccion);

    objTraza->print("Antes de cerrar");
    if (font != NULL)
    {
        /*********
        *********CUIDAO LO VOY  A DESCOMENTAR
        ******/
        TTF_CloseFont(font);
    }
    objTraza->print("Cerrada");

#ifdef GP2X
    objTraza->print("Antes de concatenar");
    strcat(fich_fuente,"/fonts/arial.ttf");
    strcat(directorio,"/fonts/");
    objTraza->print("Concatenado");
#endif

#ifdef WIN32
    strcat(fich_fuente,"\\fonts\\arial.ttf");
    strcat(directorio,"\\fonts\\");
#endif

    objTraza->print("Antes de abrir fuente",fich_fuente);
    objTraza->print("fuente pintada");
    objTraza->print("Antes de abrir fuente",size);
    if ( TTF_OpenFont(fich_fuente, size) == NULL)
    {
        objTraza->print("Antes de abrir directorio");
        //Si no hemos encontrado el tipo de letra o nos ha dado error, intentamos cargar cualquier otra fuente
        if ((dir = opendir(directorio)) != NULL)
        {
            objTraza->print("Leemos del directorio");
            while ((ent = readdir(dir)) != NULL)
            {
                strcpy(fich_fuente,directorio);
                strcat(fich_fuente,ent->d_name);
                objTraza->print("Copiamos nombre: ",fich_fuente);
                if (!get_file_attrib(fich_fuente) && (strcmp(ent->d_name,".") != 0) && (strcmp(ent->d_name,"..") != 0))
                {
                    contador++;
                    if ( TTF_OpenFont(fich_fuente, size) != NULL)
                    {
                        TTF_CloseFont(font);
                        font = TTF_OpenFont(fich_fuente, size);
                        objTraza->print("Devolvemos true");
                        return true;
                    }
                }
            }
        }
        objTraza->print("Devolvemos false");
        return false;
    }
    else
    {

        objTraza->print("En el else");
        TTF_CloseFont(font);
        font = TTF_OpenFont(fich_fuente, size);
        objTraza->print("abierto");
        return true;
    }

}

bool TPantalla::LoadFont(char *fontName, int size)
{
    printf("antes de obtener la fuente\n");
    if (font != NULL)
    {
        printf("cerramos\n");
        //TTF_CloseFont(font);
    }

    if ( TTF_OpenFont(fontName, size) == NULL)
    {
        printf("false\n");
        return false;
    }
    else
    {
        printf("true\n");
        printf("%s,%d\n",fontName,size);
        font = TTF_OpenFont(fontName, size);
        printf("abierta\n");
        crearArrayTamanyos(font,size);
        printf("arrays\n");
        return true;
    }
}




void TPantalla::setColor(SDL_Color *object, Uint8 r,Uint8 g,Uint8 b)
{
    object->r=r;
    object->g=g;
    object->b=b;
}
void TPantalla::setColor(int color)
{
    fontNumColor = color;

    switch (color)
    {
    case 0 :
        setColor(fontColor,255,0,0);
        break;
    case 1 :
        setColor(fontColor,0,0,151);
        break;
    case 2 :
        setColor(fontColor,0,255,64);
        break;
    case 3 :
        setColor(fontColor,255,255,0);
        break;
    case 4 :
        setColor(fontColor,255,128,0);
        break;
    case 5 :
        setColor(fontColor,128,64,0);
        break;
    case 6 :
        setColor(fontColor,0,0,0);
        break;
    case 7 :
        setColor(fontColor,255,255,255);
        break;
    case 8 :
        setColor(fontColor,128,0,128);
        break;
    case 9 :
        setColor(fontColor,180,180,180);
        break;
    default :
        setColor(fontColor,255,255,255);
        break;
    }
}


int TPantalla::getFontColor()
{
    //putColor(color,c_color);
    return fontNumColor;
}


void TPantalla::putColor(int color, SDL_Color *c_color)
{
    switch (color)
    {
    case 0 :
        setColor(c_color,255,0,0);
        break;
    case 1 :
        setColor(c_color,0,0,151);
        break;
    case 2 :
        setColor(c_color,0,255,64);
        break;
    case 3 :
        setColor(c_color,255,255,0);
        break;
    case 4 :
        setColor(c_color,255,128,0);
        break;
    case 5 :
        setColor(c_color,128,64,0);
        break;
    case 6 :
        setColor(c_color,0,0,0);
        break;
    case 7 :
        setColor(c_color,255,255,255);
        break;
    case 8 :
        setColor(c_color,128,0,128);
        break;
    case 9 :
        setColor(c_color,180,180,180);
        break;
    default :
        setColor(c_color,255,255,255);
        break;
    }
}

void TPantalla::setFondo(int color)
{
    switch (color)
    {
    case 0 :
        setColor(bkgColor,255,0,0);
        break;
    case 1 :
        setColor(bkgColor,0,0,151);
        break;
    case 2 :
        setColor(bkgColor,0,255,64);
        break;
    case 3 :
        setColor(bkgColor,255,255,0);
        break;
    case 4 :
        setColor(bkgColor,255,128,0);
        break;
    case 5 :
        setColor(bkgColor,128,64,0);
        break;
    case 6 :
        setColor(bkgColor,0,0,0);
        break;
    case 7 :
        setColor(bkgColor,255,255,255);
        break;
    case 8 :
        setColor(bkgColor,128,0,128);
        break;
    case 9 :
        setColor(bkgColor,180,180,180);
        break;
    default :
        setColor(bkgColor,0,0,0);
        break;
    }

    SDL_Rect pantalla = { 0,0,screen->w, screen->h};
    SDL_FillRect(screen, &pantalla, SDL_MapRGB(screen->format,bkgColor->r,bkgColor->g,bkgColor->b));
}

void TPantalla::charTab(char *dato)
{
    Uint8 tam = strlen(dato);
//    int i=0;
    for (int i=0;i<tam;i++)
        if (dato[i]=='\t')
            dato[i]=' ';

}

bool TPantalla::getJustificar()
{
    return this->justificar;
}

void TPantalla::setJustificar(bool dato_in)
{
    this->justificar = dato_in;
}


bool TPantalla::getBarra()
{
    return this->indBarra;
}

void TPantalla::setBarra(bool dato_in)
{
    this->indBarra = dato_in;
}


int TPantalla::getTamFuente(void)
{
    return tamFuente;
}

void TPantalla::setTamFuente(int dato)
{
    tamFuente = dato;
}

void TPantalla::crearArrayTamanyos(TTF_Font *font,int tamFont)
{
    int pixels = 0;
    char leido[2]={' ','\0'};
    memset(arrayTamanyos,0,255);

    for (int i=0;i < 255; i++)
    {
        leido[0] = (char)i;
        TTF_SizeText(this->font,leido,&pixels,NULL );
        //printf("i: %d, char: %c, size: %d\n",i,(char)i,pixels);
        //if (i == 32 && pixels < tamFont / 2) pixels = TTF_SizeText(this->font,"a",&pixels,NULL );
        arrayTamanyos[i]=pixels;
    }
}

int TPantalla::devolverTamanyo(unsigned char letra)
{

    if ( ((int)letra) < 255 && ((int)letra) > 0)
        return arrayTamanyos[int(letra)];
    else
        return tamFuente/2;
}

int TPantalla::devolverTamanyoS(char *letra)
{
    int tam = 0;
    int lenS = strlen(letra);

    if (letra != NULL)
        for (int i=0;i<lenS;i++)
//            if ( ((int)letra[i]) < 255 && ((int)letra[i]) > 0)
            if ( ((int)letra[i]) > 0)
                tam += arrayTamanyos[int(letra[i])];
            else
                tam += tamFuente/2;

    return tam;
}
void TPantalla::getDirActual(char *buffer)
{
    getcwd(buffer, MAXPATH);
}

void TPantalla::setDirActual(char *buffer)
{
    if (chdir(buffer) == -1)
        printf("ERROR AL CAMBIAR DE DIRECTORIO");
//    else
    //setRutaSeleccion(buffer);
}

// returns the value of rutaSeleccion
char * TPantalla::getRutaSeleccion()
{
    return rutaSeleccion;
}


// sets the value of rutaSeleccion
void TPantalla::setRutaSeleccion(char * x)
{
    //rutaSeleccion = x;
    strcpy(rutaSeleccion,x);
}

int TPantalla::contiene (char *s1, char *s2)
{
    int len_s1=0, len_s2=0; //Tamanyos de los strings
    int j=0;  //para recorrer s2
    int i=0;  //para recorrer s1

    if (s1 != NULL && s2 != NULL)
    {
        len_s1 = strlen(s1);
        len_s2 = strlen(s2);

        for (i = 0; i < len_s1; i++)
        {
            if (s1[i] == s2[j])
            {
                j++;
            }
            else if (j != len_s2)
            {
                j = 0;
                if (s1[i] == s2[j])
                {
                    j++;
                }
            }
        }
    }

    if (j == len_s2 && j != 0)
    {
        return (i-j);
    }
    else
    {
        return -1;
    }
}

int TPantalla::contiene (char *s1, char s2)
{
    int len_s1=0; //Tamanyos de los strings
    int i=0;  //para recorrer s1

    if (s1 != NULL)
    {
        len_s1 = strlen(s1);

        while (s1[i] != s2 && i<len_s1)
        {

            i++;
        }
    }

    if (i != len_s1)
    {
        return (i);
    }
    else
    {
        return -1;
    }
}

bool TPantalla::esRetorno(char dato)
{
     char carControl[] = "\r\n";
     Uint8 tam = strlen(carControl);
     bool salir = false;
     Uint8 pos = 0;

     while (!salir && pos < tam)
     {
         if (dato == carControl[pos])
         {
             salir = true;
         }
         pos++;
     }

     return salir;
}


void TPantalla::stringTrim(char *dato)
{
    Uint8 tam = strlen(dato);
    int i = tam - 1;
    bool salir = false;

    int j=0;

    while (!salir && tam > 1 && j < tam)
    {
        if (dato[0] == ' ')
        {
            //printf("Encontramos un espacio en %d\n",j);
            for (int k=1;k<tam;k++)
            {
                dato[k-1] = dato[k];
            }
            if (tam > 1) dato[tam-1] = ' ';
        }
        else
        {
            salir = true;
        }
        j++;
    }

/*
    bool salir2 = false;
    if (i > 0)
    {
        while (i >= 0 && !salir2)
        {
            printf("bucle: %d, %d\n",i,dato[i]);
            if (dato[i] != ' ' && i < tam-2 && dato[i] != '\0')
            {
                printf("salimos en: %d\n",i);
                if (dato[i+1] == ' ')
                    dato[i+1] = '\0';
                salir2 = true;
            }
            i--;
        }
*/

    if (i > 0)
    {
        //temp[0] = dato[i];
        while (i > 0 && dato[i] == ' ' )
        {
            dato[i] = '\0';
            i--;
        }
    }
}

// Devuelve verdadero si la ruta que se le pasa es un directorio
// falso en caso contrario
bool TPantalla::get_file_attrib(char *filename)
{
    struct stat statbuf;
    stat(filename, &statbuf);
//    traza *miTraza = new traza("salidita2.txt");
//    miTraza->print("get_file_attrib:filename",filename);

    //int ene = statbuf.st_mode;

//       char modo[200];
//       sprintf(modo,"%d",statbuf.st_mode);

//       miTraza->print("get_file_attrib:modo",modo);
//       miTraza->print("get_file_attrib:constante",constante);

    if (statbuf.st_mode & S_IFDIR )
        return true;
    else
        return false;
}

void TPantalla::filtrarYMinusculas (char *varDato)
{
    int tam = strlen(varDato);
    unsigned char leido = ' ';


    for (int i=0;i<tam;i++)
    {

        leido = varDato[i];
        //Los caracteres que no pueden ser letras, seran eliminados con un espacio
        if ((int)leido < 65 || ( (int)leido > 90 && (int)leido < 97) || ((int)leido > 122 && (int)leido < 192) )
        {
            varDato[i] = ' ';
        }
        else
        //Hacemos que todas las palabras esten en minusculas
        if ((int)leido >= 65 && (int)leido <= 90 || (int)leido >= 192 && (int)leido <= 221)
        {
            varDato[i] = (int)leido+32;
        }
    }

    this->stringTrim(varDato);
}

void TPantalla::setForzarTextoRemarcar (char *varDato)
{
    if (textoForzadoRemarcar != NULL)
    {
        delete textoForzadoRemarcar;
        textoForzadoRemarcar = NULL;
    }

    if (varDato != NULL)
    {
        textoForzadoRemarcar = new char(strlen(varDato)+1);
        strcpy(textoForzadoRemarcar,varDato);
    }
    else
    {
        delete textoForzadoRemarcar;
        textoForzadoRemarcar = NULL;
    }
}

